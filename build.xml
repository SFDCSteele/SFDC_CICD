	<project name="VA usage of Salesforce Ant tasks" default="git-config" basedir="." xmlns:sf="antlib:com.salesforce" xmlns:ac="antlib:net.sf.antcontrib">

		<property file="build.properties"/>
		<property environment="env"/>
		<property name="zipParms" value="" />

		<property name="passed.envName" value="" />
		<property name="work.envName" value="" />
		<property name="work.serverurl" value="" />
		<property name="work.username" value="" />
		<property name="work.password" value="" />
		<property name="work.deploy.full.location" value="${sf.deploy.full.location}" />
		<property name="work.deploy.location" value="${sf.deploy.location}" />
		<property name="work.deploy.check.location" value="${sf.deploy.check.location}" />
		<property name="work.repo.location" value="${sf.repo.location}" />
		<property name="work.unpackaged" value="" />
		<property name="work.branch" value="" />
		<property name="work.packageNames" value="" />
		<property name="work.APEX.testClasses" value="" />
		<property name="check.APEX.testClasses" value="" />

		<property name="temp.work.nameMap" value="" />
		<ac:var name="work.nameMap" value="" />
		
		<property name="from.envName" value="" />
		<property name="from.serverurl" value="" />
		<property name="from.username" value="" />
		<property name="from.password" value="" />
		<property name="from.unpackaged" value="" />
		<property name="from.packageNames" value="" />
		<property name="from.APEX.testClasses" value="" />

		<property name="to.work.env" value="" />
		<property name="to.envName" value="" />
		<property name="to.serverurl" value="" />
		<property name="to.username" value="" />
		<property name="to.password" value="" />
		<property name="to.unpackaged" value="" />
		<property name="to.packageNames" value="" />
		<property name="to.APEX.testClasses" value="" />

		<!-- Setting default value for username, password and session id properties to empty string 
	         so unset values are treated as empty. Without this, ant expressions such as ${sf.username}
	         will be treated literally.
	         
			In your build.xml file, you can set pollWaitMillis attribute to increase the time.Like
			pollWaitMillis="40000"

	    -->

		<taskdef resource="com/salesforce/antlib.xml" uri="antlib:com.salesforce">
			<classpath>
				<pathelement location="src/build/ant-salesforce.jar" />
			</classpath>
		</taskdef>
		<taskdef resource="net/sf/antcontrib/antlib.xml" uri="antlib:net.sf.antcontrib">
			<classpath>
				<pathelement location="src/build/ant-contrib-1.0b3.jar"/>
			</classpath>
		</taskdef>

		<macrodef name = "git-config">
			<attribute name = "command" />
			<attribute name="options" default="" />
			<attribute name="failerror" default="false" />
			<element name = "args" optional = "true" />
			<sequential>
				<echo message="git @{command} @{options}" />
				<exec executable="git" failonerror="@{failerror}">
					<arg line="config @{command} @{options}" />
					<args />
				</exec>
			</sequential>
		</macrodef>
		<macrodef name = "git">
			<attribute name = "command" />
			<attribute name="options" default="" />
			<attribute name="dir" default="" />
			<attribute name="failerror" default="false" />
			<element name = "args" optional = "true" />
			<sequential>
				<echo message="git dir @{dir}" />
				<echo message="git @{command}" />
				<echo message="git @{options}" />
				<exec executable="git" dir="@{dir}" failonerror="@{failerror}">
					<arg line="@{command} @{options}" />
					<args />
				</exec>
			</sequential>
		</macrodef>
		<macrodef name = "git-clone-pull">
			<attribute name = "repository" />
			<attribute name = "dest" />
			<sequential>
				<echo message = "inside the git-clone-pull command...args: @{dir}" />
				<git command = "clone">
					<args>
						<arg value = "@{repository}" />
						<arg value = "@{dest}" />
					</args>
				</git>
				<git command = "pull" dir = "@{dest}" />
			</sequential>
		</macrodef>
		<!-- Get folders content -->
		<macrodef name="Package_fetchFolderContents">
			<attribute name="folderName"/>
			<attribute name="componentType"/>
			<attribute name="orgName"/>
			<attribute name="sfUserName"/>
			<attribute name="sfPassword"/>
			<attribute name="sfServerURL"/>

			<sequential>
				<sf:listMetadata
	                    username="@{sfUserName}"
	                    password="@{sfPassword}" 
	                    serverurl="@{sfServerURL}"
	                    metadataType="@{componentType}" 
	                    folder="@{folderName}"
	                    resultFilePath="tmp/@{orgName}-@{componentType}-@{folderName}.log"/>

				<if>
					<!-- Execute only if file created -->
					<available file="tmp/@{orgName}-@{componentType}-@{folderName}.log"/>
					<then>
						<loadfile srcfile="${basedir}/tmp/@{orgName}-@{componentType}-@{folderName}.log" property="@{orgName}.@{componentType}.@{folderName}" >
							<filterchain>
								<ignoreblank/>
								<trim/>
								<linecontains>
									<contains value="FileName:"/>
								</linecontains>

								<prefixlines prefix="&lt;members&gt;"/>
								<suffixlines suffix="&lt;/members&gt;"/>

								<tokenfilter>
									<replacestring from="FileName: reports/" to=""/>
									<replacestring from="FileName: documents/" to=""/>
									<replacestring from="FileName: email/" to=""/>
									<replacestring from="FileName: dashboards/" to=""/>
									<replacestring from="FileName: unfiled$public" to="unfiled$public"/>
									<replacestring from=".report" to=""/>
									<replacestring from=".email" to=""/>
									<replacestring from=".dashboard" to=""/>
								</tokenfilter>
							</filterchain>
						</loadfile>

						<!-- Write filtered content to snippet file -->
						<for param="line" list="${@{orgName}.@{componentType}.@{folderName}}" delimiter="${line.separator}">
							<sequential>
								<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.@{componentType}" append="true" >${tab}${tab}@{line}${line.separator}</concat>
							</sequential>
						</for>
						<!-- <echo> Extracted Report Names - ${@{orgName}.@{componentType}.@{folderName}} </echo> -->
					</then>
				</if>
			</sequential>
		</macrodef>

		<!-- Get the folder name -->
		<macrodef name="Package_computeFolderName">
			<attribute name="sfUserName"/>
			<attribute name="sfPassword"/>
			<attribute name="sfServerURL"/>
			<attribute name="metadataType"/>
			<attribute name="tmpFolderPath"/>
			<attribute name="componentType"/>
			<attribute name="orgName"/>

			<sequential>
				<sf:listMetadata
	                    username="@{sfUserName}"
	                    password="@{sfPassword}" 
	                    serverurl="@{sfServerURL}"
	                    metadataType="@{metadataType}" 
	                    resultFilePath="@{tmpFolderPath}"/>

				<echo>Output file for sf:listMetadata - @{tmpFolderPath}</echo>

				<loadfile srcfile="@{tmpFolderPath}" property="@{orgName}.@{metadataType}.onlyFolderName" >
					<filterchain>
						<trim/>
						<ignoreblank/>
						<linecontains negate="false">
							<contains value="FileName"/>
						</linecontains>
						<tokenfilter>
							<replacestring from="FileName: reports/" to=""/>
							<replacestring from="FileName: documents/" to=""/>
							<replacestring from="FileName: email/" to=""/>
							<replacestring from="FileName: dashboards/" to=""/>
							<replacestring from="FileName: unfiled$public" to="unfiled$public"/>
							<replacestring from=" " to=""/>
						</tokenfilter>
					</filterchain>
				</loadfile>

				<for param="line" list="${@{orgName}.@{metadataType}.onlyFolderName}" delimiter="${line.separator}">
					<sequential>
						<echo message="Folder - @{line}"/>

						<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.@{componentType}" append="true">${tab}${tab}&lt;members&gt;@{line}&lt;/members&gt;${line.separator}</concat>

						<Package_fetchFolderContents 
	                    folderName="@{line}" 
	                    componentType="@{componentType}" 
	                    orgName="@{orgName}" 
	                    sfusername="@{sfUserName}"
	                    sfPassword="@{sfPassword}" 
	                    sfServerURL="@{sfServerURL}" />

					</sequential>
				</for>
			</sequential>
		</macrodef>

		<macrodef name="GeneratePackage_xml">
			<attribute name="sfUserName"/>
			<attribute name="sfPassword"/>
			<attribute name="sfServerURL"/>
			<!-- This attribute decides where to copy Package.xml -->
			<attribute name="packageXMLPath"/>
			<attribute name="packageXMLTemplate"/>
			<attribute name="orgName"/>

			<sequential>
				<echo message="Creating files in packageXMLPath: @{packageXMLPath} ---baseDir ${basedir}/tmp/@{orgName}..."/>

				<!-- Delete All files first else it will append to existing old file -->
				<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>
				<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report"/>
				<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate"/>
				<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document"/>

				<!-- Create Fresh Files -->
				<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>
				<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report"/>
				<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate"/>
				<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document"/>

				<!-- Empty Content in each file -->
				<property name="blankVal" value=""/>
				<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard" append="true">${blankVal}</concat>
				<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report" append="true">${blankVal}</concat>
				<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate" append="true">${blankVal}</concat>
				<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document" append="true">${blankVal}</concat>


				<!-- 
	                Imp Step :
	                1. We must assign Password to property and then pass to other Macro else it will ignore
	                   all occurrences of '$' in password
	                2. Property Name must be unique so safer to add Org Name also
	            -->
				<property name="sfPassword.prop.@{orgName}" value="@{sfPassword}"/>

				<Package_computeFolderName 
	                sfUserName="@{sfUserName}"
	                sfPassword="$${sfPassword.prop.@{orgName}}" 
	                sfServerURL="@{sfServerURL}"
	                metadataType="DashboardFolder"
	                componentType = "Dashboard"                
	                tmpFolderPath = "${basedir}/tmp/@{orgName}.DashboardFolders.log" 
	                orgName="@{orgName}" 
	            />
				<!--
	               tmpFolderPath = "./tmp/@{orgName}.DashboardFolders.log" 
	            -->
				<Package_computeFolderName 
	                sfUserName="@{sfUserName}"
	                sfPassword="$${sfPassword.prop.@{orgName}}" 
	                sfServerURL="@{sfServerURL}"
	                metadataType="ReportFolder"  
	                componentType="Report"
	                tmpFolderPath = "${basedir}/tmp/@{orgName}.ReportFolders.log" 
	                orgName="@{orgName}" 
	            />

				<Package_computeFolderName 
	                sfUserName="@{sfUserName}"
	                sfPassword="$${sfPassword.prop.@{orgName}}" 
	                sfServerURL="@{sfServerURL}"
	                metadataType="EmailFolder" 
	                componentType="EmailTemplate"
	                tmpFolderPath = "${basedir}/tmp/@{orgName}.EmailFolders.log" 
	                orgName="@{orgName}" 
	            />

				<Package_computeFolderName 
	                sfUserName="@{sfUserName}"
	                sfPassword="$${sfPassword.prop.@{orgName}}" 
	                sfServerURL="@{sfServerURL}"
	                metadataType="DocumentFolder" 
	                componentType = "Document" 
	                tmpFolderPath = "${basedir}/tmp/@{orgName}.DocumentFolders.log" 
	                orgName="@{orgName}" 
	            />


				<!-- Load Generated File content which has Snippet of Package.xml in Property -->
				<loadfile property="@{orgName}.DashboardFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard" failonerror="false"/>
				<loadfile property="@{orgName}.ReportFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report" failonerror="false"/>
				<loadfile property="@{orgName}.EmailFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate" failonerror="false"/>
				<loadfile property="@{orgName}.DocumentFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document" failonerror="false"/>
				<echo message="load file property @{orgName}.DashboardFolder.log.edit --> @{orgName}.DashboardFolder.log.edit"/>
				<echo message="srcFile ${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>

				<copy file="@{packageXMLTemplate}" tofile="@{packageXMLPath}" overwrite="true" failonerror="true"/>
				<replace file="@{packageXMLPath}">
					<replacefilter token="_replaceReportMembersTag_" value="${@{orgName}.ReportFolder.log.edit}"/>
					<replacefilter token="_replaceEmailTemplateMembersTag_" value="${@{orgName}.EmailFolder.log.edit}"/>
					<replacefilter token="_replaceDashboardMembersTag_" value="${@{orgName}.DashboardFolder.log.edit}"/>
					<replacefilter token="_replaceDocumentMembersTag_" value="${@{orgName}.DocumentFolder.log.edit}"/>
				</replace>
				<echo message="99.PROCESS COMPLETE..."/>

			</sequential>
		</macrodef>


		<!-- Use this proxy when in Proxy required network -->
		<target name="proxy">
			<setproxy proxyhost="${proxy.host}" proxyport="${proxy.port}"  />
		</target>

		<!-- Use this empty proxy setting outside Proxy Required network -->
		<target name="noproxy">
		</target>

		<!-- ===================================================================================================================================================== -->
		<!-- Setup related targets -->

		<!-- login to  Git and Migration tool targets -->
		<target name="git-config" unless="file.found" description="Set the user.name user.email for git">
			<echo message="Performing git Configuration..."/>	
			<property environment="serverURL"/>
			<echo message="101-Passed in environment variable: ${serverURL}..."/>
			<git-config command="--global">
				<args>
					<arg value="user.name" />
					<arg value="${sf.gitusername}" />
				</args>
			</git-config>
			<git-config command="--global">
				<args>
					<arg value="user.email" />
					<arg value="${sf.gituseremail}" />
				</args>
			</git-config>
			<git command="remote">
				<args>
					<arg value="remove"/>
					<arg value="origin"/>
				</args>
			</git>
			<git command="remote">
				<args>
					<arg value="add"/>
					<arg value="origin"/>
					<arg value="${sf.repository}"/>
				</args>
			</git>
			<git-config command="--global">
				<args>
					<arg value="--list" />
				</args>
			</git-config>
			<git command="remote">
				<args>
					<arg value="-v"/>
				</args>
			</git>
			<git command="status" />
		</target>

		<target name="setEnv">
			<ac:var name="env_count" value="1"/>
			<ac:var name="passed.envName" value="${envName}"/>
			<ac:if>
				<isset property="toEnvName"/>
				<then>
					<ac:var name="to.work.env" value="${toEnvName}"/>
				</then>
			</ac:if>
			<ac:for list="${passed.envName}" param="passed.env.name">
				<sequential>
					<ac:var name="env_index" value="0"/>
					<ac:var name="loop_index" value="1"/>
					<ac:for list="${sf.envName}" param="env.name">
						<sequential>
							<ac:if>
								<equals arg1="@{env.name}" arg2="@{passed.env.name}"/>
								<then>
									<ac:var name="env_index" value="${loop_index}"/>
									<ac:if>
										<equals arg1="${env_count}" arg2="1"/>
										<then>
											<ac:var name="work.envName" value="@{env.name}"/>
											<ac:var name="from.envName" value="@{env.name}"/>
										</then>
										<else>
											<ac:var name="to.envName" value="@{env.name}"/>
										</else>
									</ac:if>
								</then>
							</ac:if>
							<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />	
						</sequential>
					</ac:for>
					<ac:if>
						<not>
							<equals arg1="${env_index}" arg2="0"/>
						</not>
						<then>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.serverurl}" param="server.url">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:if>
												<equals arg1="${env_count}" arg2="1"/>
												<then>
													<ac:var name="work.serverurl" value="@{server.url}"/>
													<ac:var name="from.serverurl" value="@{server.url}"/>
												</then>
												<else>
													<ac:var name="to.serverurl" value="@{server.url}"/>
												</else>
											</ac:if>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.username}" param="user.name">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:if>
												<equals arg1="${env_count}" arg2="1"/>
												<then>
													<ac:var name="work.username" value="@{user.name}"/>
													<ac:var name="from.username" value="@{user.name}"/>
												</then>
												<else>
													<ac:var name="to.username" value="@{user.name}"/>
												</else>
											</ac:if>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.password}" param="password">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:if>
												<equals arg1="${env_count}" arg2="1"/>
												<then>
													<ac:var name="work.password" value="@{password}"/>
													<ac:var name="from.password" value="@{password}"/>
												</then>
												<else>
													<ac:var name="to.password" value="@{password}"/>
												</else>
											</ac:if>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.unpackaged}" param="unpackaged">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:if>
												<isset property="packageName"/>
												<then>
													<ac:var name="work.unpackaged" value="${packageName}"/>
												</then>
												<else>
													<ac:var name="work.unpackaged" value="@{unpackaged}"/>
												</else>
											</ac:if>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.APEX.testClasses}" param="apexTestCases">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:var name="check.APEX.testClasses" value="@{apexTestCases}"/>
											<ac:var name="work.APEX.testClasses" value="@{apexTestCases}"/>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>
							<ac:var name="loop_index" value="1"/>
							<ac:for list="${sf.branch}" param="branch">
								<sequential>
									<ac:if>
										<equals arg1="${env_index}" arg2="${loop_index}"/>
										<then>
											<ac:var name="work.branch" value="@{branch}"/>
										</then>
									</ac:if>
									<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
								</sequential>
							</ac:for>				
							<!--ac:if>
								<not>
									<equals arg1="${check.APEX.testClasses}" arg2="none"/>
								</not>
								<then>
									<ac:var name="work_index" value="1"/>
									<ac:for list="${check.APEX.testClasses}" param="apexTestCases" delimiter="|">
										<sequential>
											<ac:if>
												<not>
													<equals arg1="${work_index}" arg2="1"/>
												</not>
												<then>
													<ac:var name="work.APEX.testClasses" value="${work.APEX.testClasses},@{apexTestCases}"/>
												</then>
												<else>
													<ac:var name="work.APEX.testClasses" value="@{apexTestCases}"/>
												</else>
											</ac:if>
											<ac:math result="work_index" operand1="${work_index}" operation="+" operand2="1" datatype="int" />
										</sequential>
									</ac:for>
								</then>
							</ac:if-->
						</then>
					</ac:if>
					<ac:math result="env_count" operand1="${env_count}" operation="+" operand2="1" datatype="int" />
				</sequential>
			</ac:for>
			<echo message="Environment          : ${work.envName}"/>
			<echo message="        ServerURL    : ${work.serverurl}" />
			<echo message="         username    : ${work.username}"/>
			<echo message="         password:   : ${work.password}"/>
			<echo message="  deploy location    : ${work.deploy.location}"/>
			<echo message="deploy check location: ${work.deploy.check.location}"/>
			<echo message="    repo location    : ${work.repo.location}"/>
			<echo message="       unpackaged    : ${work.unpackaged}"/>
			<echo message="           branch    : ${work.branch}"/>
			<echo message="APEX Test Classes    : ${work.APEX.testClasses}"/>
			<!-- echo message="    packageNames: ${work.packageNames}"/ -->
			<echo message="================================================="/>
			<ac:if>
				<not>
					<equals arg1="${env_count}" arg2="2"/>
				</not>
				<then>
					<echo message="To Environment   : ${to.envName}"/>
					<echo message="        ServerURL: ${to.serverurl}" />
					<echo message="         username: ${to.username}"/>
					<echo message="  deploy location: ${work.deploy.location}"/>
					<echo message="    repo location: ${work.repo.location}"/>
					<echo message="       unpackaged: ${work.unpackaged}"/>
					<echo message="APEX Test Classes: ${work.APEX.testClasses}"/>
					<echo message="================================================="/>
				</then>
			</ac:if>
			
		</target>

		<target name="clean">
			<ac:if>
				<isset property="clean"/>
				<then>
					<echo message="Performing clean on ${work.deploy.location}...."/>
					<delete includeEmptyDirs="true" verbose="true" failonerror="false">
						<fileset dir="${work.deploy.location}">
							<include name="**" />
							<include name="**/*.*" />
						</fileset>
					</delete>
				</then>
			</ac:if>
		</target>

		<!-- ===================================================================================================================================================== -->
		<!-- Salesforce extract/deploy related targets -->

		<target name="retrieveNamedPackage" depends="setEnv">
			<echo message="---------------------------"/>
			<echo message="Inside retrieveNamedPackage"/>
			<echo message="---------------------------"/>
			<input message="Change Set Name" addproperty="work.changesetname" />
			<input message="Output Package name" addproperty="work.packagename" />

			<echo message="Retrieving package ${work.changesetname} saving to ${work.packagename}..."/>
			<mkdir dir="${work.deploy.location}/namedPackage" />
			<sf:retrieve
				username="${work.username}" 
				password="${work.password}" 
				serverurl="${work.serverurl}" 
				retrieveTarget="${work.deploy.location}/namedPackage" 
				singlePackage="false"
				apiVersion="43.0"
				packageNames="${work.changesetname}" />
			<echo message="${work.deploy.location}/namedPackage/${work.changesetname}/package.xml to ${work.packagename}"/>
			<copy file="${work.deploy.location}/namedPackage/${work.changesetname}/package.xml"
				tofile="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.packagename}" overwrite="true" failonerror="true"/>
		</target>

		<!-- Git and Migration tool targets -->
		<target name="build-PackageXML" depends="noproxy,setEnv">
			<!-- Change to proxy if do not want to use proxy -->
			<!-- Create tmp folder if missing -->
			<mkdir dir="tmp"/>
			<GeneratePackage_xml
	            sfUserName = "${work.username}" 
	            sfPassword = "${work.password}"
	            sfServerURL = "${work.serverurl}"
	            packageXMLPath = "${work.deploy.location}/Package.xml" 
	        	packageXMLTemplate = "${sf.packageXMLTemplate}" 
	           	orgName="${work.envName}"  />

		</target>

		<target name="extract" description="Extract all configuration from the org based on package.xml to local repository">
			<ac:for list="${envName}" param="env.name">
				<sequential>
					<echo message="========================================="/>
					<echo message="Processing environment: @{env.name}"/>
					<ac:var name="work.envName" value="@{env.name}"/>
					<antcall target="extract-step">
						<param name="envName" value="@{env.name}"/>
					</antcall>
				</sequential>
			</ac:for>
		</target>


		<target name="extract-step" depends="clean,setEnv" description="Extract step for an individual environment-configuration from the org based on package.xml to local repository">
			<mkdir dir="${work.deploy.location}/src"/>
			<!-- Retrieve the contents into another directory -->
			<ac:for list="${work.unpackaged}" param="unpackage.name" delimiter="|">
				<sequential>
					<echo message="1-Extracting unpackaged from ${work.serverurl} to ${work.deploy.location} using package ${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}" />
					<sf:retrieve
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						retrieveTarget="${work.deploy.location}/src"
						unpackaged="${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}"/>
				</sequential>
			</ac:for>
			<ac:if>
				<isset property="copy"/>
				<then>
					<echo message="Performing copy from ${work.deploy.location}/src to ${work.repo.location}/src"/>
					<copy todir="${work.repo.location}/src">
					  <fileset dir="${work.deploy.location}/src"/>
					</copy>
				</then>
				<!-- ac:if>
					<isset property="push"/>
					<then>
						<echo message="Pushing code from ${work.repo.location}/src to ${sf.repository}/${work.branch}"/>
						<copy todir="${work.repo.location}/src">
						  <fileset dir="${work.deploy.location}/src"/>
						</copy>
					</then>
				</ac:if -->
			</ac:if>
		</target>
		
		<target name="extract-deploy" description="Extract all configuration from the org based on package.xml to local repository">
			<ac:var name="env_index" value="0"/>
			<ac:var name="passedEnv" value="${envName}"/>
			<ac:var name="action" value="extract"/>
			<ac:if>
				<isset property="check"/>
				<then>
					<ac:var name="work.deploy.location" value="${work.deploy.check.location}"/>
					<echo message="##Check is true---setting deploy location to: ${work.deploy.location}!"/>
				</then>
			</ac:if>
			<ac:if>
				<isset property="clean"/>
				<then>
					<ac:var name="work.deploy.location" value="${work.deploy.location}"/>
					<antcall target="clean">
						<param name="work.deploy.location" value="${work.deploy.location}"/>
					</antcall>
				</then>
			</ac:if>
			<ac:for list="${passedEnv}" param="env.name">
				<sequential>
					<echo message="========================================="/>
					<ac:var name="envName" value="@{env.name}"/>
					<ac:var name="work.envName" value="@{env.name}"/>
					<ac:if>
						<equals arg1="${env_index}" arg2="0"/>
						<then>
							<echo message="Extracting from environment: @{env.name}"/>
						</then>
						<else>
							<echo message="Deploying to environment: @{env.name}"/>
							<ac:var name="action" value="deploy"/>
						</else>
					</ac:if>
					<antcall target="extract-deploy-step">
						<param name="envName" value="@{env.name}"/>
						<param name="action" value="${action}"/>
					</antcall>
					<ac:math result="env_index" operand1="${env_index}" operation="+" operand2="1" datatype="int" />	
				</sequential>
			</ac:for>
		</target>


		<target name="extract-deploy-step" depends="setEnv" description="Extract step for an individual environment-configuration from the org based on package.xml to local repository">
			<ac:var name="deployLocation" value="${work.deploy.location}"/>
			<ac:if>
				<isset property="check"/>
				<then>
					<ac:var name="deployLocation" value="${work.deploy.check.location}"/>
				</then>
			</ac:if>
			<mkdir dir="${deployLocation}/src"/>
			<!-- Retrieve the contents into another directory -->
			<ac:if>
				<equals arg1="${action}" arg2="extract"/>
				<then>
					<echo message="Extracting from environment: ${work.envName}(${work.serverurl}) to ${deployLocation} using package ${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.unpackaged}"/>
					<sf:retrieve
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						retrieveTarget="${deployLocation}/src"
						unpackaged="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.unpackaged}"/>
				</then>
				<else>
					<ac:if>
						<isset property="code"/>
						<then>
							<echo message="###################################################################################################"/>
							<echo message="Performing a Code deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
							<echo message="###################################################################################################"/>
							<sf:deploy
								username="${work.username}"
								password="${work.password}"
								serverurl="${work.serverurl}"
								maxPoll="${sf.maxPoll}"
								pollWaitMillis="${sf.pollWaitMillis}"
								singlePackage="true"
								ignoreWarnings="true"
								deployRoot="${work.deploy.location}/src"
								testLevel="RunSpecifiedTests"
								allowMissingFiles="true"	
								checkOnly="true"
								rollbackOnError="true">
						        <runTest>VIEWS_AddVeteranCmpControllerTest</runTest>
						        <runTest>VIEWS_Add_Case_Task_Controller_Test</runTest>
						        <runTest>VIEWS_BatchCaseAttHistoryRecUpdateTest</runTest>
						        <runTest>VIEWS_BatchCaseOwnerTransferTest</runTest>
						        <runTest>VIEWS_BatchCaseTaskOwnerTransferTest</runTest>
						        <runTest>VIEWS_BulkOwnerTransferControllerTest</runTest>
						        <runTest>VIEWS_BulkOwnerTransferDATest</runTest>
						        <runTest>VIEWS_BulkOwnerTransferServiceTest</runTest>
						        <runTest>VIEWS_CaseAccessUtilityTest</runTest>
						        <runTest>VIEWS_CaseSensitivityUpdateBatchTest</runTest>
						        <runTest>VIEWS_CaseSensitivityUtilityTest</runTest>
						        <runTest>VIEWS_CaseTaskTriggerHandlerTest</runTest>
						        <runTest>VIEWS_DocumentManagerDataAccessorTest</runTest>
						        <runTest>VIEWS_FunctionalQueueHandlerTest</runTest>
						        <runTest>VIEWS_FunctionalQueueUtilityTest</runTest>
						        <runTest>VIEWS_MVISearchCmpControllerTest</runTest>
						        <runTest>VIEWS_OrganizationDenestingBatchTest</runTest>
						        <runTest>VIEWS_PopulateDenestedOrgsBatchTest</runTest>
						        <runTest>VIEWS_SubFunctionalQueueHandlerTest</runTest>
						        <runTest>VIEWS_TestUtilityTest</runTest>
						        <runTest>VIEWS_VetContactSearchCmpControllerTest</runTest>
							</sf:deploy>
						</then>
						<else>
							<echo message="###################################################################################################"/>
							<echo message="Performing a deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
							<echo message="###################################################################################################"/>
							<sf:deploy
								username="${work.username}"
								password="${work.password}"
								serverurl="${work.serverurl}"
								maxPoll="${sf.maxPoll}"
								pollWaitMillis="${sf.pollWaitMillis}"
								singlePackage="true"
								ignoreWarnings="true"
								deployRoot="${work.deploy.location}/src"
								allowMissingFiles="true"	
								rollbackOnError="true">
							</sf:deploy>
						</else>
					</ac:if>
					<echo message="Deploying to environment: ${work.envName}(${work.serverurl}) from ${deployLocation}"/>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${deployLocation}/src"
						allowMissingFiles="true"	
						logType="Detail"
						rollbackOnError="true"/>
				</else>
			</ac:if>
		</target>

		<!--target name="deploy" depends="setEnv,prepBuildDir,retrieveCurrentArtifacts,findFlowsToDeploy" unless="file.found" description="Deploy to the SF Org based on the package.xml"-->
		<target name="deploy" depends="setEnv" unless="file.found" description="Deploy to the SF Org based on the package.xml">
			<echo message="Deploying the Package ${work.unpackaged} from ${work.deploy.location} to ${work.serverurl}--single package" />
			<copy file="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.unpackaged}"
				tofile="${work.deploy.location}/src/package.xml" overwrite="true" failonerror="true"/>

			<ac:if>
				<isset property="check"/>
				<then>
					<echo message="###################################################################################################"/>
					<echo message="Performing a Check deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
					<echo message="###################################################################################################"/>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						allowMissingFiles="true"	
						checkOnly="true"
						logType="Detail"
						rollbackOnError="true"/>
				</then>
				<else>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						allowMissingFiles="true"	
						logType="Detail"
						rollbackOnError="true"/>
				</else>
			</ac:if>
		</target>

		<target name="deploy-code" depends="setEnv,prepBuildDir,retrieveCurrentArtifacts,findFlowsToDeploy" unless="file.found" description="Deploy to the SF Org based on the package.xml">
			<echo message="Deploying the CODE Package ${work.unpackaged} from ${work.deploy.location} to ${work.serverurl}--single package" />
			<!-- input message="Enter scripts to be executed:"  addproperty="execute_tests"/ -->

			<copy file="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.unpackaged}"
				tofile="${work.deploy.location}/src/package.xml" overwrite="true" failonerror="true"/>
			
			<ac:var name="runTests" value=""/>
			<ac:for list="${execute_tests}"  param="env.package.name" delimiter="|">
				<sequential>
					<ac:var name="runTests" value="&lt;runTest&gt;@{env.package.name}&lt;/runTest&gt;${runTests}"/>
				</sequential>
			</ac:for>
			
			<echo message="preparing to execute the following scripts: ${runTests}"/>

			<ac:if>
				<isset property="check"/>
				<then>
					<echo message="###################################################################################################"/>
					<echo message="Performing a Check deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
					<echo message="###################################################################################################"/>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						testLevel="RunSpecifiedTests"
						allowMissingFiles="true"	
						checkOnly="true"
						rollbackOnError="true">
						<runTest>MilestoneTimeCalculatorTest</runTest>
						<runTest>MyMilestoneTimeCalculatorTest</runTest>
						<runTest>ViewsAppealsDATest</runTest>
						<runTest>ViewsAppealsParseJsonResponseTest</runTest>
						<runTest>ViewsAppealsSearchControllerTest</runTest>
						<runTest>ViewsAppealsSearchTest</runTest>
						<runTest>ViewsDACDATest</runTest>
						<runTest>ViewsDACEncryptedJsonParserTest</runTest>
						<runTest>ViewsDACParseJsonResponseTest</runTest>
						<runTest>ViewsDACSearchTest</runTest>
						<runTest>ViewsInteractionHistoryDATest</runTest>
						<runTest>ViewsInteractionHistoryTest</runTest>
						<runTest>ViewsMVIGuidTest</runTest>
						<runTest>ViewsMVIParseJsonResponseTest</runTest>
						<runTest>ViewsVeteranDATest</runTest>
						<runTest>ViewsVeteranSearchTest</runTest>
						<runTest>WH_Hotline_PatsRCaseRestControllerTest</runTest>
						<runTest>WH_Hotline_PatsRMulesoftCallOutTest</runTest>
						<runTest>WH_Hotline_PatsRResponseTest</runTest>
						<runTest>WH_Hotline_PatsrApiTest</runTest>
						<runTest>VIEWS_AddVeteranCmpControllerTest</runTest>
						<runTest>VIEWS_Add_Case_Task_Controller_Test</runTest>
						<runTest>VIEWS_BatchCaseAttHistoryRecUpdateTest</runTest>
						<runTest>VIEWS_BatchCaseOwnerTransferTest</runTest>
						<runTest>VIEWS_BatchCaseTaskOwnerTransferTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferControllerTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferDATest</runTest>
						<runTest>VIEWS_BulkOwnerTransferServiceTest</runTest>
						<runTest>VIEWS_CaseAccessUtilityTest</runTest>
						<runTest>VIEWS_CaseSensitivityUpdateBatchTest</runTest>
						<runTest>VIEWS_CaseSensitivityUtilityTest</runTest>
						<runTest>VIEWS_CaseTaskTriggerHandlerTest</runTest>
						<runTest>VIEWS_DocumentManagerDataAccessorTest</runTest>
						<runTest>VIEWS_FunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_FunctionalQueueUtilityTest</runTest>
						<runTest>VIEWS_MVISearchCmpControllerTest</runTest>
						<runTest>VIEWS_OrganizationDenestingBatchTest</runTest>
						<runTest>VIEWS_PopulateDenestedOrgsBatchTest</runTest>
						<runTest>VIEWS_SubFunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_TestUtilityTest</runTest>
						<runTest>VIEWS_VetContactSearchCmpControllerTest</runTest>
						<runTest>VBA_QMS_SRPageControllerTest</runTest>
						<runTest>VICRequestControllerTest</runTest>
						<runTest>WS_EducationComplaintTest</runTest>
						<!--runTest>WH_Hotline_PatsrApiTest</runTest-->
					</sf:deploy>
				</then>
				<else>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						testLevel="RunSpecifiedTests"
						allowMissingFiles="true"	
						rollbackOnError="true">
				        <runTest>MilestoneTimeCalculatorTest</runTest>
				        <runTest>MyMilestoneTimeCalculatorTest</runTest>
						<runTest>ViewsAppealsDATest</runTest>
						<runTest>ViewsAppealsParseJsonResponseTest</runTest>
						<runTest>ViewsAppealsSearchControllerTest</runTest>
						<runTest>ViewsAppealsSearchTest</runTest>
						<runTest>ViewsDACDATest</runTest>
						<runTest>ViewsDACEncryptedJsonParserTest</runTest>
						<runTest>ViewsDACParseJsonResponseTest</runTest>
						<runTest>ViewsDACSearchTest</runTest>
						<runTest>ViewsInteractionHistoryDATest</runTest>
						<runTest>ViewsInteractionHistoryTest</runTest>
						<runTest>ViewsMVIGuidTest</runTest>
						<runTest>ViewsMVIParseJsonResponseTest</runTest>
						<runTest>ViewsVeteranDATest</runTest>
						<runTest>ViewsVeteranSearchTest</runTest>
						<runTest>WH_Hotline_PatsRCaseRestControllerTest</runTest>
						<runTest>WH_Hotline_PatsRMulesoftCallOutTest</runTest>
						<runTest>WH_Hotline_PatsRResponseTest</runTest>
						<runTest>WH_Hotline_PatsrApiTest</runTest>
					</sf:deploy>
				</else>
			</ac:if>
		</target>
		<!--
		logType="Detail"
		-->
		
		<!-- ===================================================================================================================================================== -->
		<!-- git related targets -->

		<target name="git-clone" unless="file.found" description="Create directory structure, clone the remote repository and the pull that latest source">
			<echo message="Cloning the repository ${sf.repository} to ${sf.init.repo.location}" />
			<echo message="Deleting all extracted directories...${sf.init.repo.location}	"/>
			<delete dir=".git"/>
			<delete dir="${sf.init.repo.location}/src"/>
			<!-- defaultexcludes remove=".gitignore"/ -->
			<delete includeEmptyDirs="true" verbose="true">
				<fileset dir=".">
					<include name="${sf.init.repo.location}/*.*" />
					<include name="${sf.init.repo.location}/.gitignore" />
					<include name="${sf.init.repo.location}/.*" />
					<include name="${sf.init.repo.location}/**/*.*" />
					<include name="${sf.init.repo.location}/.*.*" />
					<exclude name="*,xml" />
					<exclude name="*build.*" />
					<exclude name=".gitignore" />
				</fileset>
			</delete>
			<delete dir="${sf.init.repo.location}"/>
			<git command="init" />
			<git command="clone">
				<args>
					<arg value="--branch" />
					<arg value="${sf.develop_branch}" />
					<arg value="${sf.repository}" />
					<arg value="${sf.init.repo.location}" />
				</args>
			</git>
			<git command="checkout">
				<args>
					<arg value="-b" />
					<arg value="${sf.develop_branch}" />
				</args>
			</git>
			<copy todir="${sf.init.repo.location}">
			  <fileset dir="./">
					<include name="build.*" />
				</fileset>
			</copy>
			<git command="status" />
		</target>

		<target name="git-pull" unless="file.found" description="Update the current local repository from the remote repository">
			<ac:if>
				<isset property="setBranch"/>
				<then>
					<ac:var name="branchName" value="${setBranch}"/>
				</then>
				<else>
					<ac:var name="branchName" value="${work.branch}"/>
				</else>
			</ac:if>
			<echo message="Pulling updates from the repository ${sf.repository} (branch ${branchName}) to ${sf.repo.location}" />
			<git command="checkout">
				<args>
					<!-- arg value="-b" /-->
					<arg value="${branchName}" />
				</args>
			</git>
			<git command="pull">
				<args>
					<arg value="-v" />
					<arg value="origin" />
					<!-- arg value="${sf.repository}" / -->
					<arg value="${branchName}" />
					<!-- arg value="${dev.location}" / -->
				</args>
			</git>
			<git command="status" />
		</target>


		<target name="git-push" description="Push changes in the local repository to the remote repository">
			<ac:if>
				<isset property="commitMessage"/>
				<then>
					<ac:var name="commit-message" value="${commitMessage}"/>
					<echo message="Commit message passed in: ${commit-message}"/>
				</then>
				<else>
					<input message="Commit message" addproperty="commit-message" />
				</else>
			</ac:if>
			<ac:if>
				<isset property="setBranch"/>
				<then>
					<ac:var name="branchName" value="${setBranch}"/>
				</then>
				<else>
					<ac:var name="branchName" value="${sf.develop_branch}"/>
				</else>
			</ac:if>
			<echo message="Commiting all changes with message ${commit-message} to branch ${branchName}" />
			<git command="checkout">
				<args>
					<arg value="${branchName}" />
				</args>
			</git>
			<git command="add">
				<args>
					<arg value="." />
				</args>
			</git>
			<git command="commit">
				<args>
					<arg value="-m ${commit-message}" />
				</args>
			</git>
			<git command="push">
				<args>
					<arg value="origin" />
					<arg value="${branchName}" />
				</args>
			</git>
		</target>
		<!-- arg value="==set-upstream" / -->

		<target name="extract-push" depends="setEnv" description="Extract all configuration from the org based on package.xml to local repository and then push to the remote repository">
			<echo message="##Extracting from the url ${work.serverurl} and pushing to the repository ${sf.repository} from ${sf.repo.location}..." />
			<antcall target="git-pull"/>
			<antcall target="extract"/>
			<antcall target="git-push"/>
		</target>

		<!-- ===================================================================================================================================================== -->
		<!-- DTC related targets -->

		<target name="extract-all-packages" description="Extract all packages from the specific SF environment">
			<ac:if>
				<isset property="check"/>
				<then>
					<ac:var name="${work.deploy.location}" value="${work.deploy.check.location}"/>
				</then>
			</ac:if>
			<ac:if>
				<isset property="clean"/>
				<then>
					<ac:var name="${work.deploy.location}" value="${work.deploy.check.location}"/>
					<antcall target="clean"/>
				</then>
			</ac:if>
			<mkdir dir="${work.deploy.location}"/>
			<echo message="looping through these environments: ${sf.envName}..."/>
			<ac:for list="${sf.envName}" param="env.name">
				<sequential>
					<echo message="========================================="/>
					<ac:var name="envName" value="@{env.name}"/>
					<echo message="Processing environment: @{env.name}"/>
					<ac:var name="work.envName" value="@{env.name}"/>
					<antcall target="extract-package"/>
				</sequential>
			</ac:for>
		</target>

		<target name="extract-package" depends="setEnv" description="Extract step for an individual environment based on the packages specified">
			<!-- Retrieve the contents into another directory -->
			<echo message="-------------------------------------------"/>
			<echo message="Processing environment: ${work.envName} package: ${work.unpackaged}..."/>
			<ac:for list="${work.unpackaged}" param="unpackage.name" delimiter="|">
				<sequential>
				<ac:if>
					<equals arg1="@{unpackage.name}" arg2="Package_All.xml"/>
					<then>
						<echo message="This ALL package and as such will not be part of the extract (probably for ISITDTC, UAT, Staging, or PROD)..."/>
					</then>
					<else>
						<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
						<echo message="********************************************************************************************************************************************************"/>
						<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
						<echo message="Extracting unpackaged from ${work.serverurl} to ${work.deploy.location} using package ${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}" />
						<sf:retrieve
							username="${work.username}"
							password="${work.password}"
							serverurl="${work.serverurl}"
							maxPoll="${sf.maxPoll}"
							pollWaitMillis="${sf.pollWaitMillis}"
							retrieveTarget="${work.deploy.location}/src"
							unpackaged="${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}"/>
						</else>
					</ac:if>
				</sequential>
			</ac:for>
			<ac:if>
				<isset property="copy"/>
				<then>
					<echo message="Performing copy from ${work.deploy.location}/src to ${work.repo.location}/src"/>
					<copy todir="${work.repo.location}/src">
					  <fileset dir="${work.deploy.location}/src"/>
					</copy>
				</then>
			</ac:if>
		</target>

		<target name="deploy-all-individual" depends="setEnv" description="Deploy all packages to the specific SF environment, one at a time">
			<!--echo message="================================================="/>
			<echo message="From Environment : ${from.envName}"/>
			<echo message="        ServerURL: ${from.serverurl}" />
			<echo message="         username: ${from.username}"/>
			<echo message="  deploy location: ${work.deploy.location}"/>
			<echo message="    repo location: ${work.repo.location}"/>
			<echo message="       unpackaged: ${work.unpackaged}"/>
			<echo message="APEX Test Classes: ${work.APEX.testClasses}"/>
			<echo message="================================================="/>
			<echo message="================================================="/>
			<echo message="To Environment   : ${to.envName}"/>
			<echo message="        ServerURL: ${to.serverurl}" />
			<echo message="         username: ${to.username}"/>
			<echo message="  deploy location: ${work.deploy.location}"/>
			<echo message="    repo location: ${work.repo.location}"/>
			<echo message="       unpackaged: ${work.unpackaged}"/>
			<echo message="APEX Test Classes: ${work.APEX.testClasses}"/>
			<echo message="================================================="/ -->
			<ac:for list="${sf.unpackaged}" param="env.package.name">
				<sequential>
					<ac:if>
						<equals arg1="@{env.package.name}" arg2="Package_All.xml"/>
						<then>
							<echo message="This ALL package and as such will not be part of the extract (probably for ISITDTC, UAT, Staging, or PROD)..."/>
						</then>
						<else>
							<echo message="\n\n\n"/>
							<echo message="================================================================================================================================"/>
							<echo message="================================================================================================================================"/>
							<echo message="Extracting from: ${from.envName} Deploying to: ${to.envName} with package @{env.package.name}"/>
							<echo message="-------------------------------------------"/>
							<echo message="Processing package: @{env.package.name}..."/>
							<ac:for list="@{env.package.name}" param="unpackage.name" delimiter="|">
								<sequential>
									<mkdir dir="${work.deploy.location}/@{unpackage.name}/src"/>
									<!-- antcall target="clean"/ -->
									<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
									<echo message="********************************************************************************************************************************************************"/>
									<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
									<echo message="Extracting unpackaged from ${from.serverurl} to ${work.deploy.location}/@{unpackage.name}/src using package ${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}" />
									<sf:retrieve
										username="${from.username}"
										password="${from.password}"
										serverurl="${from.serverurl}"
										maxPoll="${sf.maxPoll}"
										pollWaitMillis="${sf.pollWaitMillis}"
										retrieveTarget="${work.deploy.location}/@{unpackage.name}/src"
										unpackaged="${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}"/>
									<antcall target="deploy-package">
										<param name="envPackageName" value="@{unpackage.name}"/>
									</antcall>
								</sequential>
							</ac:for>
						</else>
					</ac:if>
				</sequential>
			</ac:for>
		</target>

		<!-- target name="deploy-package" depends="prepBuildDir,retrieveCurrentArtifacts,findFlowsToDeploy" unless="file.found" description="Deploy to the SF Org based on the package.xml" -->
		<target name="deploy-package" unless="file.found" description="Deploy to the SF Org based on the package.xml">
			<echo message="Deploying the Package ${envPackageName} from ${work.deploy.location} to ${to.serverurl}--single package" />
			<copy file="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${envPackageName}"
				tofile="${work.deploy.location}/src/package.xml" overwrite="true" failonerror="true"/>

			<ac:if>
				<isset property="check"/>
				<then>
					<echo message="###################################################################################################"/>
					<echo message="Performing a Check deploy of ${work.deploy.location}/${envPackageName}/src to ${to.serverurl}..." />
					<echo message="###################################################################################################"/>
					<sf:deploy
						username="${to.username}"
						password="${to.password}"
						serverurl="${to.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/${envPackageName}/src"
						allowMissingFiles="true"	
						checkOnly="true"
						logType="Detail"
						rollbackOnError="true"/>
				</then>
				<else>
					<sf:deploy
						username="${to.username}"
						password="${to.password}"
						serverurl="${to.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						allowMissingFiles="true"	
						logType="Detail"
						rollbackOnError="true"/>
				</else>
			</ac:if>
		</target>

		<target name="deploy-package_x" depends="clean" description="Extract step for an individual environment based on the packages specified">
			<!-- Retrieve the contents into another directory -->
			<echo message="-------------------------------------------"/>
			<echo message="Processing package: ${envPackageName}..."/>
			<ac:if>
				<equals arg1="${envPackageName}" arg2="Package_All.xml"/>
				<then>
					<echo message="This ALL package and as such will not be part of the extract (probably for ISITDTC, UAT, Staging, or PROD)..."/>
				</then>
				<else>
					<ac:for list="${envPackageName}" param="unpackage.name" delimiter="|">
						<sequential>
							<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
							<echo message="********************************************************************************************************************************************************"/>
							<echo message="--------------------------------------------------------------------------------------------------------------------------------------------------------"/>
							<echo message="Extracting unpackaged from ${from.serverurl} to ${work.deploy.location} using package ${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}  check=${check}..." />
							<sf:retrieve
								username="${from.username}"
								password="${from.password}"
								serverurl="${from.serverurl}"
								maxPoll="${sf.maxPoll}"
								pollWaitMillis="${sf.pollWaitMillis}"
								retrieveTarget="${work.deploy.location}/src"
								unpackaged="${work.repo.location}/${sf.package.location}/${sf.release_branch}/@{unpackage.name}"/>
						</sequential>
					</ac:for>
				</else>
			</ac:if>
			<ac:if>
				<isset property="copy"/>
				<then>
					<echo message="Performing copy from ${work.deploy.location}/src to ${work.repo.location}/src"/>
					<copy todir="${work.repo.location}/src">
					  <fileset dir="${work.deploy.location}/src"/>
					</copy>
				</then>
			</ac:if>
		</target>
		
		<!--target name="deploy-full" depends="setEnv,prepBuildDir,retrieveCurrentArtifacts"-->
			<target name="deploy-full" depends="setEnv,prepBuildDir,retrieveCurrentArtifacts">
			<!-- build the full package.xml -->
			<ac:if>
				<isset property="check"/>
				<then>
					<ac:var name="check" value="true"/>
				</then>
				<else>
					<ac:var name="check" value="false"/>
				</else>
			</ac:if>
			<antcall target="git-pull"/>
			<antcall target="createFullPackage">
				<param name="check" value="${check}"/>
			</antcall>
			<echo message="build.xml VERSION 100.10..............."/>
			<input message="1-Please verify Package_ALL.xml before proceeding-press return to continue"/>
			<ant antfile="full_build.xml" target="execute-deploy">
				<property name="check" value="${check}"/>
				<property name="work.envName" value="${work.envName}" />
				<property name="work.serverurl" value="${work.serverurl}" />
				<property name="work.username" value="${work.username}" />
				<property name="work.password" value="${work.password}" />
				<property name="work.deploy.location" value="${sf.deploy.full.location}" />
				<property name="zip.deploy.location" value="${sf.deploy.location}/zip" />
				<property name="maxPoll" value="${sf.maxPoll}"/>
				<property name="pollWaitMillis" value="${sf.pollWaitMillis}"/>
				<property name="sf.release_branch" value="${sf.release_branch}"/>
				<property name="work.unpackaged" value="${work.unpackaged}"/>
			</ant>
			<!--antcall target="deploy-full-step" /-->
		</target>
	 
		<target name="deploy-full-step" depends="setEnv,prepBuildDir,retrieveCurrentArtifacts,findFlowsToDeploy">
			<echo message="Performing copy of ${work.unpackaged} from ./src/${sf.release_branch}/${work.unpackaged} to ./src"/>
			<copy file="./src/${sf.release_branch}/${work.unpackaged}"
				tofile="./src/package.xml" overwrite="true" failonerror="true"/>
			<antcall target="git-pull"/>
			<ac:if>
				<isset property="check"/>
				<then>
					<echo message="###################################################################################################"/>
					<echo message="Performing a Check deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
					<echo message="###################################################################################################"/>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						testLevel="RunSpecifiedTests"
						allowMissingFiles="true"	
						checkOnly="true"
						rollbackOnError="true">
						<runTest>MilestoneTimeCalculatorTest</runTest>
						<runTest>MyMilestoneTimeCalculatorTest</runTest>
						<runTest>ViewsAppealsDATest</runTest>
						<runTest>ViewsAppealsParseJsonResponseTest</runTest>
						<runTest>ViewsAppealsSearchControllerTest</runTest>
						<runTest>ViewsAppealsSearchTest</runTest>
						<runTest>ViewsDACDATest</runTest>
						<runTest>ViewsDACEncryptedJsonParserTest</runTest>
						<runTest>ViewsDACParseJsonResponseTest</runTest>
						<runTest>ViewsDACSearchTest</runTest>
						<runTest>ViewsInteractionHistoryDATest</runTest>
						<runTest>ViewsInteractionHistoryTest</runTest>
						<runTest>ViewsMVIGuidTest</runTest>
						<runTest>ViewsMVIParseJsonResponseTest</runTest>
						<runTest>ViewsVeteranDATest</runTest>
						<runTest>ViewsVeteranSearchTest</runTest>
						<runTest>WH_Hotline_PatsRCaseRestControllerTest</runTest>
						<runTest>WH_Hotline_PatsRMulesoftCallOutTest</runTest>
						<runTest>WH_Hotline_PatsRResponseTest</runTest>
						<runTest>WH_Hotline_PatsrApiTest</runTest>
						<runTest>VIEWS_Add_Case_Task_Controller_Test</runTest>
						<runTest>VIEWS_AddVeteranCmpControllerTest</runTest>
						<runTest>VIEWS_BatchCaseAttHistoryRecUpdateTest</runTest>
						<runTest>VIEWS_BatchCaseOwnerTransferTest</runTest>
						<runTest>VIEWS_BatchCaseTaskOwnerTransferTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferControllerTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferDATest</runTest>
						<runTest>VIEWS_BulkOwnerTransferServiceTest</runTest>
						<runTest>VIEWS_CaseAccessUtilityTest</runTest>
						<runTest>VIEWS_CaseSensitivityUpdateBatchTest</runTest>
						<runTest>VIEWS_CaseSensitivityUtilityTest</runTest>
						<runTest>VIEWS_CaseTaskTriggerHandlerTest</runTest>
						<runTest>VIEWS_CaseTriggerHandlerTest</runTest>
						<runTest>VIEWS_DocumentManagerDataAccessorTest</runTest>
						<runTest>VIEWS_FunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_FunctionalQueueMemberHandlerTest</runTest>
						<runTest>VIEWS_FunctionalQueueUtilityTest</runTest>
						<runTest>VIEWS_MVISearchCmpControllerTest</runTest>
						<runTest>VIEWS_OrganizationDenestingBatchTest</runTest>
						<runTest>VIEWS_PopulateDenestedOrgsBatchTest</runTest>
						<runTest>VIEWS_SA_Form_Controller_Test</runTest>
						<runTest>VIEWS_SubFunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_TestUtilityTest</runTest>
						<runTest>VIEWS_VetContactSearchCmpControllerTest</runTest>
						<runTest>ViewsUploadAttachmentControllerTest</runTest>
						<runTest>VBA_QMS_SRPageControllerTest</runTest>
						<runTest>VICRequestControllerTest</runTest>
						<runTest>WS_EducationComplaintTest</runTest>
						<runTest>TestEmployeeCompositeKey</runTest>
					</sf:deploy>
				</then>
				<else>
					<sf:deploy
						username="${work.username}"
						password="${work.password}"
						serverurl="${work.serverurl}"
						maxPoll="${sf.maxPoll}"
						pollWaitMillis="${sf.pollWaitMillis}"
						singlePackage="true"
						ignoreWarnings="true"
						deployRoot="${work.deploy.location}/src"
						testLevel="RunSpecifiedTests"
						allowMissingFiles="true"	
						rollbackOnError="true">
						<runTest>MilestoneTimeCalculatorTest</runTest>
						<runTest>MyMilestoneTimeCalculatorTest</runTest>
						<runTest>ViewsAppealsDATest</runTest>
						<runTest>ViewsAppealsParseJsonResponseTest</runTest>
						<runTest>ViewsAppealsSearchControllerTest</runTest>
						<runTest>ViewsAppealsSearchTest</runTest>
						<runTest>ViewsDACDATest</runTest>
						<runTest>ViewsDACEncryptedJsonParserTest</runTest>
						<runTest>ViewsDACParseJsonResponseTest</runTest>
						<runTest>ViewsDACSearchTest</runTest>
						<runTest>ViewsInteractionHistoryDATest</runTest>
						<runTest>ViewsInteractionHistoryTest</runTest>
						<runTest>ViewsMVIGuidTest</runTest>
						<runTest>ViewsMVIParseJsonResponseTest</runTest>
						<runTest>ViewsVeteranDATest</runTest>
						<runTest>ViewsVeteranSearchTest</runTest>
						<runTest>WH_Hotline_PatsRCaseRestControllerTest</runTest>
						<runTest>WH_Hotline_PatsRMulesoftCallOutTest</runTest>
						<runTest>WH_Hotline_PatsRResponseTest</runTest>
						<runTest>WH_Hotline_PatsrApiTest</runTest>
						<runTest>VIEWS_Add_Case_Task_Controller_Test</runTest>
						<runTest>VIEWS_AddVeteranCmpControllerTest</runTest>
						<runTest>VIEWS_BatchCaseAttHistoryRecUpdateTest</runTest>
						<runTest>VIEWS_BatchCaseOwnerTransferTest</runTest>
						<runTest>VIEWS_BatchCaseTaskOwnerTransferTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferControllerTest</runTest>
						<runTest>VIEWS_BulkOwnerTransferDATest</runTest>
						<runTest>VIEWS_BulkOwnerTransferServiceTest</runTest>
						<runTest>VIEWS_CaseAccessUtilityTest</runTest>
						<runTest>VIEWS_CaseSensitivityUpdateBatchTest</runTest>
						<runTest>VIEWS_CaseSensitivityUtilityTest</runTest>
						<runTest>VIEWS_CaseTaskTriggerHandlerTest</runTest>
						<runTest>VIEWS_DocumentManagerDataAccessorTest</runTest>
						<runTest>VIEWS_FunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_FunctionalQueueUtilityTest</runTest>
						<runTest>VIEWS_MVISearchCmpControllerTest</runTest>
						<runTest>VIEWS_OrganizationDenestingBatchTest</runTest>
						<runTest>VIEWS_PopulateDenestedOrgsBatchTest</runTest>
						<runTest>VIEWS_SubFunctionalQueueHandlerTest</runTest>
						<runTest>VIEWS_TestUtilityTest</runTest>
						<runTest>VIEWS_VetContactSearchCmpControllerTest</runTest>
						<runTest>VBA_QMS_SRPageControllerTest</runTest>
						<runTest>VICRequestControllerTest</runTest>
						<runTest>WS_EducationComplaintTest</runTest>
						<runTest>TestEmployeeCompositeKey</runTest>
					</sf:deploy>
				</else>
			</ac:if>

		</target>
		
		<target name="deploy-updates" depends="setEnv">
			<!-- build the full package.xml -->
			<!--antcall target="createFullPackage" /-->
	 
			<!-- pull from the release branch to make sure local and remote are in sync -->
			<ac:if>
				<isset property="setBranch"/>
				<then>
					<ac:var name="branchName" value="${setBranch}"/>
				</then>
				<else>
					<ac:var name="branchName" value="${sf.release_branch}"/>
				</else>
			</ac:if>
			<ac:if>
				<isset property="setPackage"/>
				<then>
					<ac:var name="packageName" value="${setPackage}"/>
				</then>
				<else>
					<ac:var name="packageName" value="${work.unpackaged}"/>
				</else>
			</ac:if>
			<echo message="Extracting all changes from branch ${branchName} using the package ${packageName}" />
			<git command="checkout">
				<args>
					<arg value="${branchName}" />
				</args>
			</git>
			<echo message="Performing copy of ${work.unpackaged} from ${work.repo.location}/${sf.package.location}/${sf.release_branch}/${work.unpackaged} to ${work.deploy.location}/src"/>
		    <mkdir dir="${work.deploy.location}/zip/src"/>
			<copy file="${work.repo.location}/${sf.package.location}/${sf.release_branch}/${packageName}"
				tofile="${work.deploy.location}/zip/src/package.xml" overwrite="true" failonerror="true"/>
			<echo message="Executing" />
			<exec executable="/bin/bash">
				<arg value="deploy_updates.sh"/>
				<arg value="${work.deploy.location}/zip/deploy_changes.zip"/>
				<arg value="src/package.xml"/>
				<arg value="${sf.release_branch}"/>
			</exec>

			<!-- git extract the diff/changes and zip -->
			<!-- deploy zip to the specified SF environment -->
		</target>
			
		<target name="backup">
			<copy todir="../archive/work/Releases">
			  <fileset dir="${work.repo.location}/src/build/Releases"/>
			</copy>
			<copy file="build.xml" todir="../archive/work/build"/>
			<copy file="build.properties" todir="../archive/work/build"/>
			<copy file="deploy_updates.sh" todir="../archive/work/build"/>
			<!-- copy file="old_build.xml" todir="../../archive/work/build"/>
			<copy file="old_build.properties" todir="../../archive/work/build"/ -->
		</target>

		<!-- ===================================================================================================================================================== -->
		<!-- worker related targets -->

	    <target name="retrieveCurrentArtifacts" depends="">
		   <echo message="Retriving artifacts from ${work.serverurl} with package ${work.deploy.full.location}/src/build/excludeFromDeploy.xml"/>
			<ac:if>
				<isset property="noFlow"/>
				<then>
					<echo message="SKIPPING the extraction of Current Artifacts!!"/>
				</then>
				<else>
			       <sf:retrieve username="${work.username}"
			       	password="${work.password}"
			       	serverurl="${work.serverurl}"
			       	retrieveTarget="build"
			       	unpackaged="${work.deploy.full.location}/src/build/excludeFromDeploy.xml" />
				</else>
			</ac:if>
	    </target>

	    <target name="prepBuildDir">
	       <delete dir="build"/>
	       <mkdir dir="build"/>
	    </target>

	  	<target name="findFlowsToDeploy">
	  	   <script language="javascript"><![CDATA[
	          var File = java.io.File;
	          var FileWriter = java.io.FileWriter;
			  var deployDirectory = project.getProperty( "work.repo.location" );
			  var release       = project.getProperty( "sf.release_branch" );

	          function version(xml) {
	             var matches = (''+ xml).match(/activeVersionNumber>(\d+)</);
	             if (matches) {
	                return parseInt(matches[1], 10);
	             }
	          }

	          function getFileContents(javaFile) {
	             var contents = '';
	             var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(javaFile.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	             for (var i = 0; i < lines.size(); i++) {
	                contents += lines.get(i);
	             }
	             return contents;
	          }

	          function getFlowVersion(flowFile) {
	             var content = getFileContents(flowFile);
	             return version(content);
	          }

	          function createFileset(dir) {
	             var fileset = project.createDataType('fileset');
	             fileset.setDir(new File(dir));
	             return fileset;
	          };

	          function removeLinesFromPackageXML(removeLines) {
	            packagexml = new File(deployDirectory+'/src/', "package.xml");
	            var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(packagexml.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	            var fr = new FileWriter(deployDirectory+"/src/package.xml");

	            outer: for (var i = 0; i < lines.size(); i++) {
	  	          //java.lang.System.out.println(""+(i+1)+"-Findflows: line: "+lines.get(i));
	              for (var j = 0; j < removeLines.length; j++) {
	                if (lines.get(i).contains(removeLines[j])) {
	                  java.lang.System.out.println("Removing the following from package.xml: " + removeLines[j]);
	                  continue outer;
	                }
	              }
	              fr.write(lines.get(i));
	              fr.write(java.lang.System.getProperty("line.separator"));
	            }
	            fr.close();
	          }

	          function getFlowsToDeployFromXML() {
	            packagexml = new File(deployDirectory+'/src/', "package.xml");
	            var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(packagexml.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	            var flowsWeWantToDeploy = new Array()
	            outer: for (var i = 0; i < lines.size(); i++) {
	              if(lines.get(i).contains("Begin Flows")) {
	                  var count=1;
	                  do {
					      java.lang.System.out.println(""+(i+1)+"-Flows: line: "+lines.get(i+count).split("<members>")[1].split("</members>")[0]);
	                      flowsWeWantToDeploy.push(lines.get(i+count).split("<members>")[1].split("</members>")[0]);
	                      count += 1;
	                  } while(!lines.get(i+count).contains("End Flows"));
	                  break outer;
	              }
	            }
	            //java.lang.System.out.println(flowsWeWantToDeploy[0]);
	            return flowsWeWantToDeploy;
	          }
	          var flows = getFlowsToDeployFromXML();
	          var flowsWeWantToDeleteFromXML = new Array();
	          for(i = 0; i < flows.length; i++){
	              var srcVersion = flows[i].split("-")[1]
	              var filename = flows[i].split("-")[0] + ".flowDefinition";
	              var remoteFlowDefinition = new File(deployDirectory+'/build/flowDefinitions/', filename);
	              if(!remoteFlowDefinition.exists()){
	                  continue;
	              }
	              var remoteVersion = getFlowVersion(remoteFlowDefinition);
	              if(remoteVersion == null) {
	                  continue;
	              }
	              if(remoteVersion == srcVersion) {
	                  flowsWeWantToDeleteFromXML.push(flows[i]);
	                  continue;
	              }
	          }
	          removeLinesFromPackageXML(flowsWeWantToDeleteFromXML);

	  	   ]]></script>
	  	</target>

		<target name="createFullPackage">
	  	   <script language="javascript">
	  	   	<![CDATA[
	          var File = java.io.File;
	          var FileWriter = java.io.FileWriter;  	   	
			  var fullDirectory = project.getProperty( "sf.deploy.full.location" );
			  var release       = project.getProperty( "sf.release_branch" );
			  var checkBuild    = project.getProperty( "check" );
	  	   	  var showDebug     = false;
		   	  var nameMap = new Array();
	  	   	  var fileMap = new Array();
	  	   	  var outFileMap = new Array();
	  	   	  var objectMap  = new Array();
		   	  var apexClasses = new Array();
		   	  var entitlements = new Array();
		   	  var flows = new Array();
	  	  java.lang.System.out.println("Inside createFullPackage: processing in location: "+fullDirectory+" check: "+checkBuild);
	  	   	
	  	   	  function loadFileName() {
				fileMap.push({inName:"AccountCriteriaBasedSharingRule",outName:"accountSharingRules",suffix:".*"});
		    	fileMap.push({inName:"ApexClass",outName:"classes",suffix:".*"});
		    	fileMap.push({inName:"ApexPage",outName:"pages",suffix:".*"});
		    	fileMap.push({inName:"ApexTrigger",outName:"triggers",suffix:".*"});
			  	fileMap.push({inName:"AppMenu",outName:"appMenus",suffix:".*"});
		    	fileMap.push({inName:"ApprovalProcess",outName:"approvalProcesses",suffix:".*"});
			  	fileMap.push({inName:"AssignmentRules",outName:"assignmentRules",suffix:".*"});
		    	fileMap.push({inName:"AuraDefinitionBundle",outName:"aura",suffix:"/**/*"});
			  	fileMap.push({inName:"AutoResponseRules",outName:"autoResponseRules",suffix:".*"});
		    	fileMap.push({inName:"BusinessProcess",outName:"objects",suffix:".*"});
		  	    fileMap.push({inName:"Certificate",outName:"certs",suffix:".*"});
		  	    fileMap.push({inName:"CleanDataService",outName:"cleanDataServices",suffix:".*"});
		  	    fileMap.push({inName:"Community",outName:"communities",suffix:".*"});
		  	    fileMap.push({inName:"ConnectedApp",outName:"connectedApps",suffix:".*"});
		   		fileMap.push({inName:"CustomApplication",outName:"applications",suffix:".*"});
		  	    fileMap.push({inName:"CustomApplicationComponent",outName:"customApplicationComponents",suffix:".*"});
	  	   		fileMap.push({inName:"CustomField",outName:"objects",suffix:".*"});
	  	   		fileMap.push({inName:"CustomLabel",outName:"labels",suffix:".*"});
	  	   		fileMap.push({inName:"CustomLabels",outName:"labels",suffix:".*"});
		   	    fileMap.push({inName:"CustomMetadata",outName:"customMetadata",suffix:".*"});
	  	   	    fileMap.push({inName:"CustomObject",outName:"objects",suffix:".*"});
		  	    fileMap.push({inName:"CustomObjectTranslation",outName:"objectTranslations",suffix:".*"});
		  	    fileMap.push({inName:"CustomPermission",outName:"customPermissions",suffix:".*"});
		  	    fileMap.push({inName:"CustomSite",outName:"sites",suffix:".*"});
		   	    fileMap.push({inName:"CustomTab",outName:"tabs",suffix:".*"});
		  	    fileMap.push({inName:"Dashboard",outName:"dashboards",suffix:".*"});
		   	    fileMap.push({inName:"DataCategoryGroup",outName:"datacategorygroups",suffix:".*"});
		  	    fileMap.push({inName:"DelegateGroup",outName:"delegateGroups",suffix:".*"});
		  	    fileMap.push({inName:"Document",outName:"documents",suffix:".*"});
		  	    fileMap.push({inName:"DuplicateRule",outName:"duplicateRules",suffix:".*"});
		  	    fileMap.push({inName:"EmailTemplate",outName:"email",suffix:".*"});
		  	    fileMap.push({inName:"EntitlementProcess",outName:"entitlementProcesses",suffix:".*"});
		  	    fileMap.push({inName:"EscalationRules",outName:"escalationRules",suffix:".*"});
	    	    fileMap.push({inName:"FlexiPage",outName:"flexipages",suffix:".*"});
	    	    fileMap.push({inName:"Flow",outName:"flows",suffix:".*"});
		  	    fileMap.push({inName:"FlowDefinition",outName:"flowDefinitions",suffix:".*"});
	    	    fileMap.push({inName:"GlobalValueSet",outName:"globalValueSets",suffix:".*"});
		  	    fileMap.push({inName:"GlobalValueSetTranslation",outName:"objects",suffix:".*"});
	    	    fileMap.push({inName:"Group",outName:"groups",suffix:".*"});
		  	    fileMap.push({inName:"HomePageComponent",outName:"homePageComponents",suffix:".*"});
		  	    fileMap.push({inName:"HomePageLayout",outName:"homePageLayouts",suffix:".*"});
		  	    fileMap.push({inName:"InstalledPackage",outName:"installedPackages",suffix:".*"});
		  	    fileMap.push({inName:"Letterhead",outName:"letterhead",suffix:".*"});
		   	    fileMap.push({inName:"Layout",outName:"layouts",suffix:".*"});
		   	    fileMap.push({inName:"ListView",outName:"objects",suffix:".*"});
		  	    fileMap.push({inName:"ManagedTopics",outName:"managedTopics",suffix:".*"});
		  	    fileMap.push({inName:"MatchingRule",outName:"matchingRules",suffix:".*"});
		  	    fileMap.push({inName:"MatchingRules",outName:"matchingRules",suffix:".*"});
		  	    fileMap.push({inName:"Network",outName:"networks",suffix:".*"});
		  	    fileMap.push({inName:"NetworkBranding",outName:"networkBranding",suffix:".*"});
		  	    fileMap.push({inName:"PathAssistant",outName:"pathAssistants",suffix:".*"});
		   	    fileMap.push({inName:"PermissionSet",outName:"permissionsets",suffix:".*"});
		  	    fileMap.push({inName:"Profile",outName:"profiles",suffix:".*"});
		  	    fileMap.push({inName:"ProfilePasswordPolicy",outName:"profilePasswordPolicies",suffix:".*"});
		  	    fileMap.push({inName:"ProfileSessionSetting",outName:"profileSessionSettings",suffix:".*"});
		   	    fileMap.push({inName:"Queue",outName:"queues",suffix:".*"});
		  	    fileMap.push({inName:"QuickAction",outName:"quickActions",suffix:".*"});
	    	    fileMap.push({inName:"RecordType",outName:"reportTypes",suffix:".*"});
		  	    fileMap.push({inName:"RemoteSiteSetting",outName:"remoteSiteSettings",suffix:".*"});
		  	    fileMap.push({inName:"Report",outName:"reports",suffix:".*"});
		   	    fileMap.push({inName:"ReportType",outName:"reportTypes",suffix:".*"});
		   	    fileMap.push({inName:"Role",outName:"roles",suffix:".*"});
		  	    fileMap.push({inName:"SamlSsoConfig",outName:"samlssoconfigs",suffix:".*"});
		  	    fileMap.push({inName:"Settings",outName:"settings",suffix:".*"});
		  	    fileMap.push({inName:"SharingCriteriaRule",outName:"sharingRules",suffix:".*"});
		  	    fileMap.push({inName:"SharingRules",outName:"sharingRules",suffix:".*"});
		  	    fileMap.push({inName:"SharingSet",outName:"sharingSets",suffix:".*"});
		  	    fileMap.push({inName:"SiteDotCom",outName:"siteDotComSites",suffix:".*"});
		  	    fileMap.push({inName:"StaticResource",outName:"staticresources",suffix:".*"});
		  	    fileMap.push({inName:"TopicsForObjects",outName:"topicsForObjects",suffix:".*"});
	    	    fileMap.push({inName:"ValidationRule",outName:"objects",suffix:".*"});
		  	    fileMap.push({inName:"WebLink",outName:"weblinks",suffix:".*"});
	    	    fileMap.push({inName:"WorkflowRule",outName:"workflows",suffix:".*"});
		  	    fileMap.push({inName:"Workflow",outName:"workflows",suffix:".*"});
		   	    //fileMap.push({inName:"Queue",outName:"queues",suffix:".*"});
	  	   	
	  	  
	  	   	  }
	 	   	
	  	   	  function getFileContents(fName,passedMap) {
	  	   		var packageFile = new File(fName);
		        var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(packageFile.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	  	   	    nameMap = passedMap;
	   	   		var members = new Array();
	  	   		var nameFound = false;
	  	   		var memberFound = false;
		   		var existingMembers = new Array();
	  	   		  //read through lines in the file
			  	  for (var i = 0; i < lines.size(); i++) {
	  	   				//is the line read a member line? if so, save it off
	  	   				if ( lines.get(i).contains("<members>") ) {
							//java.lang.System.out.println("\t\t\processing member: "+lines.get(i).split("<members>")[1].split("</members>")[0]);  
	  	   					members.push(lines.get(i).split("<members>")[1].split("</members>")[0]);
	  	   				//is the existing line a name line? see if the name is saved, if so copy the members to it.  Otherwiwse, add it and its members
	  	   				} else if ( lines.get(i).contains("<name>")) {
							if ( showDebug ) java.lang.System.out.println("\tprocessing name: "+lines.get(i).split("<name>")[1].split("</name>")[0]);
	  	   					nameFound=false;
	  	   	                for ( var j=0;j < nameMap.length; j++ ) {
	  	   						//look to see if the name has already been saved
								if ( nameMap[j].name == lines.get(i).split("<name>")[1].split("</name>")[0])  {
	  	   							nameFound = true;
	  	  							if ( showDebug ) java.lang.System.out.println("\t\t\tfound the existing name("+nameMap[j].name+"): "+lines.get(i).split("<name>")[1].split("</name>")[0]+" members: "+nameMap[j].members.length);
									existingMembers = nameMap[j].members;
									for (var k=0;k<existingMembers.length; k++ ) {
	  	   								for ( l=0;l<members.length;l++ ) {
	  	  									//if ( showDebug ) java.lang.System.out.println("\t\t\t\tcomparing these member: "+existingMembers[k]+"==>"+members[l]);
	  	   									if ( existingMembers[k] == members[l] ) {
	  	   										memberFound = true;
	  	   										break;
	  	   									}
	  	   								}
	  	   								if ( !memberFound ) {
											members.push(existingMembers[k]);
	  	   								} else {
	  	   								}
	  	   								memberFound = false;
									}
									nameMap[j].members=members;
									members = new Array();
									break;
								}//if
				     		}//for
							if ( !nameFound) {
								nameMap.push({name:lines.get(i).split("<name>")[1].split("</name>")[0],members: members});
								if ( showDebug ) java.lang.System.out.println("\t\t\tSAVING the name("+nameMap[j].name+"): "+lines.get(i).split("<name>")[1].split("</name>")[0]+" members: "+nameMap[j].members.length);
	   						}
							members = new Array();
	  	   				}//if
	  	          }//for
	  	  		nameMap.sort(function(a, b){ // sort object by object Name
			  	  	var nameA=a.name.toLowerCase(), nameB=b.name.toLowerCase()
			  	  	if (nameA < nameB) //sort string ascending
			  	   		return -1 
			  	  	if (nameA > nameB)
			  	  		return 1
			  	  	return 0 //default return value (no sorting)
			  	  })
	  	   		return nameMap.sort();
	  	   	  }
	  	   	
	  	   	  
		   	  function getFlowFiles () {
		   		  var fName = "test";
		   		  var equals = false;
			   	  var flows = new Array();
			  	  var folder = new File(fullDirectory+"/build/flows");
			  	  var listOfFiles = folder.listFiles();
				  if ( showDebug )  java.lang.System.out.println("Inside getFlowFiles...");
		   	      if ( listOfFiles != null && listOfFiles.length > 0 ) {
			 	      for ( var i=0;i<listOfFiles.length;i++ ) {
	  	  				flows.push(listOfFiles[i]);
			 	      }
		   		  } else {
		  			java.lang.System.out.println("There are no flows to process...");
		   		  }
			  	  return flows;		
		   	  }
		   	  function getEntitlementFiles () {
		   		  var fName = "test";
		   		  var equals = false;
			   	  var entitlements = new Array();
			  	  var folder = new File(fullDirectory+"/build/entitlementProcesses");
			  	  var listOfFiles = folder.listFiles();
	      		  if ( showDebug )  java.lang.System.out.println("Inside getEntitlementFiles...");
	  	   	      if ( listOfFiles != null && listOfFiles.length > 0 ) {
			 	      for ( var i=0;i<listOfFiles.length;i++ ) {
			  			entitlements.push(listOfFiles[i]);
			 	      }
	  	   		  } else {
	  	  			java.lang.System.out.println("There are no entitlements to process...");
	  	   		  }
			  	  return entitlements;		
		   	  }
	  	   	  function getPackageFiles () {
	  	   		  var fName = "test";
	  	   		  var equals = false;
			   	  nameMap = new Array();
			  	  var folder = new File(fullDirectory+"/src/build/Releases/"+release+"");
			  	  var listOfFiles = folder.listFiles();
			
	  	  			if ( showDebug )  java.lang.System.out.println("...looking in directory: "+fullDirectory+"/src/build/Releases/"+release);
	  	  			//java.lang.System.out.println("list of files: "+listOfFiles);
			        for (var i = 0; i < listOfFiles.length; i++) {
	  	   			  fName = listOfFiles[i];  	   	
	  	   	
	  	   			  if (fName != (fullDirectory+"/src/build/Releases/"+release+"/.DS_Store") && 
	  	  						fName != (fullDirectory+"/src/build/Releases/"+release+"/Package_ALL.xml") && 
								fName != (fullDirectory+"/src/build/Releases/Package_ALL_template.xml")) {
				  	  	java.lang.System.out.println("2-file: "+fName);
				   	    nameMap = getFileContents(fName,nameMap);
	  	   			  }
			        }
	   		  	return nameMap;
	  	   	  }
	  	   	  function saveObject(dirName,objectName,extName) {
	  	   			var workObject = "";
	  	   			var found=false;
	  	   			for ( var i=0;i<objectMap.length;i++ ) {
	  	   				workObject = dirName+"/"+objectName+extName;
	  	   				if ( objectMap[i].name == workObject ) {
	  	   					found = true;
	  	   					break;
	  	   				}
	  	   			}
	  	   			if ( !found ) {
		 				workObject = dirName+"/"+objectName+extName;
						objectMap.push({name:workObject});
	  	   			}
					//objectMap.push({name:fileMap[k].outName+"/"+nameMap[j].members[l].split('.')[0]+fileMap[k].suffix});
	  	   	  }
	  	   	  function loadPackageTemplate(nameMap) {
			  	  var template = new File(fullDirectory+"/src/build/Releases/Package_ALL_template.xml");
			      var packageAll = new FileWriter(fullDirectory+"/src/build/Releases/"+release+"/Package_ALL.xml");
		          var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(template.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	  	   		  var flowFound = false;
	  	   		  var entitlementFound = false;
	  	   	      var member = "";
	  	   		  var work   = "";
	  	   		  var writeCount = 0;
		 		  java.lang.System.out.println("###loadPackageTemplate: Input file validation-flows: "+flows.length+" entitlements: "+entitlements.length);
	  	   	      for (var i=0;i<lines.length;i++ ) {
		  	   			if ( lines.get(i).contains("<!-- INSERT HERE -->")) { 
	  	  					packageAll.write("\t<types>");
					  	    packageAll.write(java.lang.System.getProperty("line.separator"));
		   					for (var k=0;k<nameMap.length;k++) {
	  	   						flowFound = false;
	  	   						entitlementFound = false;
			   					for ( var j=0;j<nameMap[k].members.length;j++ ) {
	  	   							member = fullDirectory+"/build/flows/"+nameMap[k].members[j]+".flow";
	  	   							if ( nameMap[k].name == "Flow" ) {
										for ( var l=0;l<flows.length;l++ ) {
	  	   									work = flows[l];
											//java.lang.System.out.println("CHECKING: "+nameMap[k].name+" member: "+member+"-->"+work+" match: "+(member===work));
		  	   								if ( member == work ) {
		  	  									java.lang.System.out.println("Skipping flow: "+nameMap[k].name+" flow "+flows[l]+"-already exists...");
		  	   									flowFound = true;
		  	   									break;
		  	   								}
		  	   							}
									}
									member = fullDirectory+"/build/entitlementProcesses/"+nameMap[k].members[j]+".entitlementProcess";
									if ( nameMap[k].name == "EntitlementProcess" ) {
										for ( var l=0;l<entitlements.length;l++ ) {
											work = entitlements[l];
											//java.lang.System.out.println("CHECKING: "+nameMap[k].name+" member: "+member+"-->"+work+" match: "+(member===work));
											if ( member == work ) {
												java.lang.System.out.println("Skipping entitlement "+nameMap[k].name+" entitlement "+entitlements[l]+"-already exists...");
										 		entitlementFound = true;
												break;
											}
										}
	  	   							}
	  	   							if ( !flowFound && !entitlementFound ) {
									  	writeCount++;
										packageAll.write("\t\t<members>"+nameMap[k].members[j]+"</members>");
								  	    packageAll.write(java.lang.System.getProperty("line.separator"));
	  	   							}
					   			}
	  	   						if ( writeCount > 0 ) {
									packageAll.write("\t\t<name>"+nameMap[k].name+"</name>");
							  	    packageAll.write(java.lang.System.getProperty("line.separator"));
									packageAll.write("\t</types>");
							  	    packageAll.write(java.lang.System.getProperty("line.separator"));
									if ( k < nameMap.length-1 ) {
										packageAll.write("\t<types>");
								  	    packageAll.write(java.lang.System.getProperty("line.separator"));
									}
								  	writeCount=0;
	  	   						}
	  	   						if ( nameMap[k].name == "ApexClass" ) {
									apexClasses = nameMap[k].members;
	  	  							java.lang.System.out.println("found "+nameMap[k].name+" with "+nameMap[k].members.length+" records("+apexClasses.length+")");
	  	   						}
	  	   					}
		  	   	        } else {
				  	    	packageAll.write(lines.get(i));
				   	  	    packageAll.write(java.lang.System.getProperty("line.separator"));
	  	   				}
	  	   	      }  	   	        	   				     
		  		packageAll.close();	   			
		  	   	project.setProperty("temp.work.nameMap",nameMap);
	  	   	  }
	  	   	function createCodeBuildXML() {
		  	  var template = new File(fullDirectory+"/src/build/deploy_template.xml");
		      var fullBuild = new FileWriter(fullDirectory+"/full_build.xml");
	          var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(template.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	  	   	  if ( showDebug ) {
		        for ( var j=0;j < outFileMap.length; j++ ) {
					java.lang.System.out.println("createCodeBuildXML: "+(j+1)+"-files to zipped: "+outFileMap[j]);
		  		}
	  	   	  }
			  if ( showDebug )  java.lang.System.out.println("createCodeBuildXML-apexClasses: "+apexClasses.length);
	   	      for (var i=0;i<lines.length;i++ ) {
		   			if ( lines.get(i).contains("<!-- INSERT CLASSES HERE -->")) { 
					   	  if ( checkBuild == "true" ) {
						  	  fullBuild.write("\t\t\t\t\tcheckOnly=\"true\"");
						  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
					   	  }
					   	  if ( apexClasses.length > 0 ) {
						  	  fullBuild.write("\t\t\t\t\ttestLevel=\"RunSpecifiedTests\"");
						  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
					   	  }
					  	  fullBuild.write("\t\t\t\t\t>");
					  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
						for ( var j=0;j<apexClasses.length;j++ ) {
	  	  				  /*java.lang.System.out.println("createCodeBuildXML-apexClass: "+apexClasses[j]+" containts TEST: "+apexClasses[j].contains("TEST")+
	  	 							 apexClasses[j].search(/test/i));*/
	  	   				  if ( apexClasses[j].search(/test/i) >= 0) {
						  	  fullBuild.write("\t\t\t\t\t<runTest>"+apexClasses[j]+"</runTest>");
						  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
	  	   				  }
						}
				} else if ( lines.get(i).contains("<!-- INSERT FILES HERE -->")) { 
			        for ( var j=0;j < outFileMap.length; j++ ) {
				  	  fullBuild.write("\t\t\t\t<include name=\""+outFileMap[j]+"\"/>");
				  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
			  		}
	 	        } else {
			  	  fullBuild.write(lines.get(i));
			  	  fullBuild.write(java.lang.System.getProperty("line.separator"));
				}
		      }  	   	        	   				     
		  	  fullBuild.close();	   			
	 	   	}
	  	   	function loadOutFileMap(nameMap) {
			    for ( var j=0;j < nameMap.length; j++ ) {
					if ( showDebug )  java.lang.System.out.println("$$"+(j+1)+"-SAVED names( name: "+nameMap[j].name+" members: "+nameMap[j].members.length);
			        for ( var k=0;k < fileMap.length; k++ ) {
						if ( nameMap[j].name == fileMap[k].inName ) {
		   					for ( var l=0;l<nameMap[j].members.length; l++ ) {
								if (nameMap[j].name == "CustomObject" || nameMap[j].name == "CustomField" || nameMap[j].name == "BusinessProcess" || 
	  	  								nameMap[j].name == "GlobalValueSetTranslation" || nameMap[j].name == "ListView" ||  nameMap[j].name == "ValidationRule" ) {
	  	   							saveObject ( fileMap[k].outName,nameMap[j].members[l].split('.')[0],fileMap[k].suffix);
									if ( showDebug )  java.lang.System.out.println("&&&&"+(j+1)+"-stripping a portion: "+nameMap[j].members[l].split('.')[0]);
	  	   						} else if (fileMap[k].outName != "NONE" ) {
									outFileMap.push(fileMap[k].outName+"/"+nameMap[j].members[l]+fileMap[k].suffix);
	  	   						}
		   					}
				   			break;
						}
					}
		   		}
	  	   		for ( var j=0;j<objectMap.length;j++ ) {
					outFileMap.push(objectMap[j].name);	  	   			
	  	   		}
	  	   	}
	  	   	loadFileName();
	  	   	flows = getFlowFiles();
		  	entitlements = getEntitlementFiles();
			java.lang.System.out.println("Input file validation-flows: "+flows.length+" entitlements: "+entitlements.length);
	 	    
	  	   	loadPackageTemplate(getPackageFiles());
			java.lang.System.out.println("BEFORE createCodeBuildXML-apexClasses: "+apexClasses.length);
	  	   	loadOutFileMap(nameMap);
	  	   	createCodeBuildXML();
	  	   	if (showDebug) {
		        for ( var j=0;j < nameMap.length; j++ ) {
					java.lang.System.out.println(""+(j+1)+"-SAVED names( name: "+nameMap[j].name+" members: "+nameMap[j].members.length);
			        for ( var k=0;k < fileMap.length; k++ ) {
						if ( nameMap[j].name == fileMap[k].inName ) {
							//outFileMap.push({name:fileMap[k].outName,members:nameMap[j].members});
	  	   					for ( var l=0;l<nameMap[j].members.length; l++ ) {
								java.lang.System.out.println("-----out name( name: /src/"+fileMap[k].outName+"/"+nameMap[j].members[l]+".*");
	  	   					}
		   		   			break;
						}
		  		  }
	  	   		}
		        for ( var j=0;j < outFileMap.length; j++ ) {
					java.lang.System.out.println("@@"+(j+1)+"-files to zipped: "+outFileMap[j]);
		  		}
	  	   	}

	  	   ]]></script>
	  		<ac:var name="work.nameMap" value="${temp.work.nameMap}"/>
	  		<!--echo message="from script ${work.nameMap}..."/-->
	  	</target>
		
		<!-- ===================================================================================================================================================== -->
		<!-- OOTB Force.com ant targets -->

		<!-- Retrieve an unpackaged set of metadata from your org -->
		<!-- The file unpackaged/package.xml lists what is to be retrieved -->
		<target name="retrieveUnpackaged">
			<mkdir dir="retrieveUnpackaged"/>
			<!-- Retrieve the contents into another directory -->
			<sf:retrieve username="${dev.username}" password="${dev.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="retrieveUnpackaged" unpackaged="unpackaged/package.xml"/>
		</target>

		<!-- Retrieve all the items of a particular metadata type -->
		<target name="bulkRetrieve">
			<sf:bulkRetrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" metadataType="${sf.metadataType}" retrieveTarget="retrieveUnpackaged"/>
		</target>

		<!-- Retrieve metadata for all the packages specified under packageNames -->
		<target name="retrievePkg">
			<sf:retrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="retrieveOutput" packageNames="${sf.pkgName}"/>
		</target>

		<!-- Deploy the unpackaged set of metadata retrieved with retrieveUnpackaged and run tests in this organization's namespace only-->
		<target name="deployUnpackaged">
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="retrieveUnpackaged" rollbackOnError="true"/>
		</target>

		<!-- Deploy a zip of metadata files to the org -->
		<target name="deployZip">
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" zipFile="${sf.zipFile}" rollbackOnError="true"/>
		</target>

		<!-- Shows deploying code & running tests for code in directory -->
		<target name="deployCode">
			<!-- Upload the contents of the "codepkg" directory, running the tests for just 1 class -->
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" testLevel="RunSpecifiedTests" rollbackOnError="true">
				<runTest>SampleDeployClass</runTest>
			</sf:deploy>
		</target>

		<!-- Shows deploying code with no TestLevel sepcified -->
		<target name="deployCodeNoTestLevelSpecified">
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" rollbackOnError="true"/>
		</target>

		<!-- Shows deploying code and running tests only within the org namespace -->
		<target name="deployCodeRunLocalTests">
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" rollbackOnError="true"  testlevel="RunLocalTests"/>
		</target>

		<!-- Shows removing code; only succeeds if done after deployCode sessionId="${sf.sessionId}" -->
		<target name="undeployCode">
			<echo message="Undeploying from ${sf.serverurl}..." />
			<sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="removecodepkg"/>
		</target>

		<!-- Shows retrieving code; only succeeds if done after deployCode -->
		<target name="retrieveCode">
			<!-- Retrieve the contents listed in the file codepkg/package.xml into the codepkg directory -->
			<sf:retrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="codepkg" unpackaged="codepkg/package.xml"/>
		</target>

		<!-- Shows deploying code, running all tests, and running tests (1 of which fails), and logging. -->
		<target name="deployCodeFailingTest">
			<!-- Upload the contents of the "codepkg" package, running all tests -->
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" testLevel="RunAllTestsInOrg" rollbackOnError="true" logType="Debugonly"/>
		</target>

		<!-- Shows check only; never actually saves to the server -->
		<target name="deployCodeCheckOnly">
			<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" checkOnly="true"/>
		</target>

		<!-- Shows quick deployment of recent validation. Set the property sf.recentValidationId to your recent check only deployment Id -->
		<target name="quickDeploy">
			<sf:deployRecentValidation  username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" recentValidationId="${sf.recentValidationId}"/>
		</target>

		<!-- Shows cancel deployment of deploy request either pending or in progress. Set property sf.requestId to Id of pending or in progress deploy request -->
		<target name="cancelDeploy">
			<sf:cancelDeploy  username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" requestId="${sf.requestId}"/>
		</target>

		<!-- Retrieve the information of all items of a particular metadata type -->
		<target name="listMetadata">
			<sf:listMetadata username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" metadataType="${sf.metadataType}"/>
		</target>

		<!-- Retrieve the information on all supported metadata type -->
		<target name="describeMetadata">
			<sf:describeMetadata username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}"/>
		</target>
	</project>
