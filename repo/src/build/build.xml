<project name="VA usage of Salesforce Ant tasks" default="git-config" basedir="." xmlns:sf="antlib:com.salesforce" xmlns:ac="antlib:net.sf.antcontrib">

	<property file="build.properties"/>
	<property environment="env"/>
	<property name="zipParms" value="" />

	<property name="passed.envName" value="" />
	<property name="work.envName" value="" />
	<property name="work.serverurl" value="" />
	<property name="work.username" value="" />
	<property name="work.password" value="" />
	<property name="work.deploy.location" value="${sf.deploy.location}" />
	<property name="work.repo.location" value="${sf.repo.location}" />
	<property name="work.unpackaged" value="" />
	<property name="work.packageNames" value="" />
	<property name="work.APEX.testClasses" value="" />
	<property name="check.APEX.testClasses" value="" />

	<property name="from.envName" value="" />
	<property name="from.serverurl" value="" />
	<property name="from.username" value="" />
	<property name="from.password" value="" />
	<property name="from.unpackaged" value="" />
	<property name="from.packageNames" value="" />
	<property name="from.APEX.testClasses" value="" />

	<property name="to.work.env" value="" />
	<property name="to.envName" value="" />
	<property name="to.serverurl" value="" />
	<property name="to.username" value="" />
	<property name="to.password" value="" />
	<property name="to.unpackaged" value="" />
	<property name="to.packageNames" value="" />
	<property name="to.APEX.testClasses" value="" />

	<!-- Setting default value for username, password and session id properties to empty string 
         so unset values are treated as empty. Without this, ant expressions such as ${sf.username}
         will be treated literally.
         
		In your build.xml file, you can set pollWaitMillis attribute to increase the time.Like
		pollWaitMillis="40000"

    -->

	<taskdef resource="com/salesforce/antlib.xml" uri="antlib:com.salesforce">
		<classpath>
			<pathelement location="/Users/williamsteele/icloud/salesforce/va/vawork/salesforce_ant_41.0/ant-salesforce.jar" />
		</classpath>
	</taskdef>
	<!-- taskdef uri="antlib:net.sf.antcontrib"
		resource="net/sf/antcontrib/antlib.xml"
		classpath="/users/williamsteele/Documents/workspace/apache-ant-1.10.1/bin/lib/ant-contrib-1.0b3.jar">
	</taskdef -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
		<classpath>
			<pathelement location="/Users/williamsteele/icloud/salesforce/va/vawork/salesforce_ant_41.0/lib/ant-contrib-1.0b3.jar"/>
		</classpath>
	</taskdef>

	<macrodef name = "git-config">
		<attribute name = "command" />
		<attribute name="options" default="" />
		<attribute name="failerror" default="false" />
		<element name = "args" optional = "true" />
		<sequential>
			<echo message="git @{command} @{options}" />
			<exec executable="git" failonerror="@{failerror}">
				<arg line="config @{command} @{options}" />
				<args />
			</exec>
		</sequential>
	</macrodef>
	<macrodef name = "git">
		<attribute name = "command" />
		<attribute name="options" default="" />
		<attribute name="dir" default="" />
		<attribute name="failerror" default="false" />
		<element name = "args" optional = "true" />
		<sequential>
			<echo message="git dir @{dir}" />
			<echo message="git @{command}" />
			<echo message="git @{options}" />
			<exec executable="git" dir="@{dir}" failonerror="@{failerror}">
				<arg line="@{command} @{options}" />
				<args />
			</exec>
		</sequential>
	</macrodef>
	<macrodef name = "git-clone-pull">
		<attribute name = "repository" />
		<attribute name = "dest" />
		<sequential>
			<echo message = "inside the git-clone-pull command...args: @{dir}" />
			<git command = "clone">
				<args>
					<arg value = "@{repository}" />
					<arg value = "@{dest}" />
				</args>
			</git>
			<git command = "pull" dir = "@{dest}" />
		</sequential>
	</macrodef>
	<!-- Get folders content -->
	<macrodef name="Package_fetchFolderContents">
		<attribute name="folderName"/>
		<attribute name="componentType"/>
		<attribute name="orgName"/>
		<attribute name="sfUserName"/>
		<attribute name="sfPassword"/>
		<attribute name="sfServerURL"/>

		<sequential>
			<sf:listMetadata
                    username="@{sfUserName}"
                    password="@{sfPassword}" 
                    serverurl="@{sfServerURL}"
                    metadataType="@{componentType}" 
                    folder="@{folderName}"
                    resultFilePath="tmp/@{orgName}-@{componentType}-@{folderName}.log"/>

			<if>
				<!-- Execute only if file created -->
				<available file="tmp/@{orgName}-@{componentType}-@{folderName}.log"/>
				<then>
					<loadfile srcfile="${basedir}/tmp/@{orgName}-@{componentType}-@{folderName}.log" property="@{orgName}.@{componentType}.@{folderName}" >
						<filterchain>
							<ignoreblank/>
							<trim/>
							<linecontains>
								<contains value="FileName:"/>
							</linecontains>

							<prefixlines prefix="&lt;members&gt;"/>
							<suffixlines suffix="&lt;/members&gt;"/>

							<tokenfilter>
								<replacestring from="FileName: reports/" to=""/>
								<replacestring from="FileName: documents/" to=""/>
								<replacestring from="FileName: email/" to=""/>
								<replacestring from="FileName: dashboards/" to=""/>
								<replacestring from="FileName: unfiled$public" to="unfiled$public"/>
								<replacestring from=".report" to=""/>
								<replacestring from=".email" to=""/>
								<replacestring from=".dashboard" to=""/>
							</tokenfilter>
						</filterchain>
					</loadfile>

					<!-- Write filtered content to snippet file -->
					<for param="line" list="${@{orgName}.@{componentType}.@{folderName}}" delimiter="${line.separator}">
						<sequential>
							<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.@{componentType}" append="true" >${tab}${tab}@{line}${line.separator}</concat>
						</sequential>
					</for>
					<!-- <echo> Extracted Report Names - ${@{orgName}.@{componentType}.@{folderName}} </echo> -->
				</then>
			</if>
		</sequential>
	</macrodef>

	<!-- Get the folder name -->
	<macrodef name="Package_computeFolderName">
		<attribute name="sfUserName"/>
		<attribute name="sfPassword"/>
		<attribute name="sfServerURL"/>
		<attribute name="metadataType"/>
		<attribute name="tmpFolderPath"/>
		<attribute name="componentType"/>
		<attribute name="orgName"/>

		<sequential>
			<sf:listMetadata
                    username="@{sfUserName}"
                    password="@{sfPassword}" 
                    serverurl="@{sfServerURL}"
                    metadataType="@{metadataType}" 
                    resultFilePath="@{tmpFolderPath}"/>

			<echo>Output file for sf:listMetadata - @{tmpFolderPath}</echo>

			<loadfile srcfile="@{tmpFolderPath}" property="@{orgName}.@{metadataType}.onlyFolderName" >
				<filterchain>
					<trim/>
					<ignoreblank/>
					<linecontains negate="false">
						<contains value="FileName"/>
					</linecontains>
					<tokenfilter>
						<replacestring from="FileName: reports/" to=""/>
						<replacestring from="FileName: documents/" to=""/>
						<replacestring from="FileName: email/" to=""/>
						<replacestring from="FileName: dashboards/" to=""/>
						<replacestring from="FileName: unfiled$public" to="unfiled$public"/>
						<replacestring from=" " to=""/>
					</tokenfilter>
				</filterchain>
			</loadfile>

			<for param="line" list="${@{orgName}.@{metadataType}.onlyFolderName}" delimiter="${line.separator}">
				<sequential>
					<echo message="Folder - @{line}"/>

					<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.@{componentType}" append="true">${tab}${tab}&lt;members&gt;@{line}&lt;/members&gt;${line.separator}</concat>

					<Package_fetchFolderContents 
                    folderName="@{line}" 
                    componentType="@{componentType}" 
                    orgName="@{orgName}" 
                    sfusername="@{sfUserName}"
                    sfPassword="@{sfPassword}" 
                    sfServerURL="@{sfServerURL}" />

				</sequential>
			</for>
		</sequential>
	</macrodef>

	<macrodef name="GeneratePackage_xml">
		<attribute name="sfUserName"/>
		<attribute name="sfPassword"/>
		<attribute name="sfServerURL"/>
		<!-- This attribute decides where to copy Package.xml -->
		<attribute name="packageXMLPath"/>
		<attribute name="packageXMLTemplate"/>
		<attribute name="orgName"/>

		<sequential>
			<echo message="Creating files in packageXMLPath: @{packageXMLPath} ---baseDir ${basedir}/tmp/@{orgName}..."/>

			<!-- Delete All files first else it will append to existing old file -->
			<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>
			<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report"/>
			<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate"/>
			<delete file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document"/>

			<!-- Create Fresh Files -->
			<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>
			<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report"/>
			<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate"/>
			<touch file="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document"/>

			<!-- Empty Content in each file -->
			<property name="blankVal" value=""/>
			<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard" append="true">${blankVal}</concat>
			<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report" append="true">${blankVal}</concat>
			<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate" append="true">${blankVal}</concat>
			<concat destfile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document" append="true">${blankVal}</concat>


			<!-- 
                Imp Step :
                1. We must assign Password to property and then pass to other Macro else it will ignore
                   all occurrences of '$' in password
                2. Property Name must be unique so safer to add Org Name also
            -->
			<property name="sfPassword.prop.@{orgName}" value="@{sfPassword}"/>

			<Package_computeFolderName 
                sfUserName="@{sfUserName}"
                sfPassword="$${sfPassword.prop.@{orgName}}" 
                sfServerURL="@{sfServerURL}"
                metadataType="DashboardFolder"
                componentType = "Dashboard"                
                tmpFolderPath = "${basedir}/tmp/@{orgName}.DashboardFolders.log" 
                orgName="@{orgName}" 
            />
			<!--
               tmpFolderPath = "./tmp/@{orgName}.DashboardFolders.log" 
            -->
			<Package_computeFolderName 
                sfUserName="@{sfUserName}"
                sfPassword="$${sfPassword.prop.@{orgName}}" 
                sfServerURL="@{sfServerURL}"
                metadataType="ReportFolder"  
                componentType="Report"
                tmpFolderPath = "${basedir}/tmp/@{orgName}.ReportFolders.log" 
                orgName="@{orgName}" 
            />

			<Package_computeFolderName 
                sfUserName="@{sfUserName}"
                sfPassword="$${sfPassword.prop.@{orgName}}" 
                sfServerURL="@{sfServerURL}"
                metadataType="EmailFolder" 
                componentType="EmailTemplate"
                tmpFolderPath = "${basedir}/tmp/@{orgName}.EmailFolders.log" 
                orgName="@{orgName}" 
            />

			<Package_computeFolderName 
                sfUserName="@{sfUserName}"
                sfPassword="$${sfPassword.prop.@{orgName}}" 
                sfServerURL="@{sfServerURL}"
                metadataType="DocumentFolder" 
                componentType = "Document" 
                tmpFolderPath = "${basedir}/tmp/@{orgName}.DocumentFolders.log" 
                orgName="@{orgName}" 
            />


			<!-- Load Generated File content which has Snippet of Package.xml in Property -->
			<loadfile property="@{orgName}.DashboardFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard" failonerror="false"/>
			<loadfile property="@{orgName}.ReportFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Report" failonerror="false"/>
			<loadfile property="@{orgName}.EmailFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.EmailTemplate" failonerror="false"/>
			<loadfile property="@{orgName}.DocumentFolder.log.edit" srcFile="${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Document" failonerror="false"/>
			<echo message="load file property @{orgName}.DashboardFolder.log.edit --> @{orgName}.DashboardFolder.log.edit"/>
			<echo message="srcFile ${basedir}/tmp/@{orgName}.Package.xml.Snnipet.Dashboard"/>

			<copy file="@{packageXMLTemplate}" tofile="@{packageXMLPath}" overwrite="true" failonerror="true"/>
			<replace file="@{packageXMLPath}">
				<replacefilter token="_replaceReportMembersTag_" value="${@{orgName}.ReportFolder.log.edit}"/>
				<replacefilter token="_replaceEmailTemplateMembersTag_" value="${@{orgName}.EmailFolder.log.edit}"/>
				<replacefilter token="_replaceDashboardMembersTag_" value="${@{orgName}.DashboardFolder.log.edit}"/>
				<replacefilter token="_replaceDocumentMembersTag_" value="${@{orgName}.DocumentFolder.log.edit}"/>
			</replace>
			<echo message="99.PROCESS COMPLETE..."/>

		</sequential>
	</macrodef>


	<!-- Use this proxy when in Proxy required network -->
	<target name="proxy">
		<setproxy proxyhost="${proxy.host}" proxyport="${proxy.port}"  />
	</target>

	<!-- Use this empty proxy setting outside Proxy Required network -->
	<target name="noproxy">
	</target>

	<!-- ===================================================================================================================================================== -->
	<!-- Setup related targets -->


	<!-- login to  Git and Migration tool targets -->
	<target name="git-config" unless="file.found" description="Set the user.name user.email for git">
		<echo message="Performing git Configuration..."/>
		<git-config command="--global">
			<args>
				<arg value="user.name" />
				<arg value="${sf.gitusername}" />
			</args>
		</git-config>
		<git-config command="--global">
			<args>
				<arg value="user.email" />
				<arg value="${sf.gituseremail}" />
			</args>
		</git-config>
		<git command="remote">
			<args>
				<arg value="remove"/>
				<arg value="origin"/>
			</args>
		</git>
		<git command="remote">
			<args>
				<arg value="add"/>
				<arg value="origin"/>
				<arg value="git@github.com:${sf.repository}"/>
			</args>
		</git>
		<git-config command="--global">
			<args>
				<arg value="--list" />
			</args>
		</git-config>
		<git command="remote">
			<args>
				<arg value="-v"/>
			</args>
		</git>
		<git command="status" />
	</target>

	<target name="setEnv">
		<ac:var name="env_count" value="1"/>
		<ac:var name="passed.envName" value="${envName}"/>
		<ac:if>
			<isset property="toEnvName"/>
			<then>
				<ac:var name="to.work.env" value="${toEnvName}"/>
			</then>
		</ac:if>
		<ac:for list="${passed.envName}" param="passed.env.name">
			<sequential>
				<ac:var name="env_index" value="0"/>
				<ac:var name="loop_index" value="1"/>
				<ac:for list="${sf.envName}" param="env.name">
					<sequential>
						<ac:if>
							<equals arg1="@{env.name}" arg2="@{passed.env.name}"/>
							<then>
								<ac:var name="env_index" value="${loop_index}"/>
								<ac:if>
									<equals arg1="${env_count}" arg2="1"/>
									<then>
										<ac:var name="work.envName" value="@{env.name}"/>
										<ac:var name="from.envName" value="@{env.name}"/>
									</then>
									<else>
										<ac:var name="to.envName" value="@{env.name}"/>
									</else>
								</ac:if>
							</then>
						</ac:if>
						<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />	
					</sequential>
				</ac:for>
				<ac:if>
					<not>
						<equals arg1="${env_index}" arg2="0"/>
					</not>
					<then>
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.serverurl}" param="server.url">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:if>
											<equals arg1="${env_count}" arg2="1"/>
											<then>
												<ac:var name="work.serverurl" value="@{server.url}"/>
												<ac:var name="from.serverurl" value="@{server.url}"/>
											</then>
											<else>
												<ac:var name="to.serverurl" value="@{server.url}"/>
											</else>
										</ac:if>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.username}" param="user.name">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:if>
											<equals arg1="${env_count}" arg2="1"/>
											<then>
												<ac:var name="work.username" value="@{user.name}"/>
												<ac:var name="from.username" value="@{user.name}"/>
											</then>
											<else>
												<ac:var name="to.username" value="@{user.name}"/>
											</else>
										</ac:if>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.password}" param="password">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:if>
											<equals arg1="${env_count}" arg2="1"/>
											<then>
												<ac:var name="work.password" value="@{password}"/>
												<ac:var name="from.password" value="@{password}"/>
											</then>
											<else>
												<ac:var name="to.password" value="@{password}"/>
											</else>
										</ac:if>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>
						<!-- ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.deploy.location}" param="deploy.location">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:var name="work.deploy.location" value="@{deploy.location}"/>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>				
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.repo.location}" param="repo.location">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:var name="work.repo.location" value="@{repo.location}"/>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for -->
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.unpackaged}" param="unpackaged">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:if>
											<isset property="packageName"/>
											<then>
												<ac:var name="work.unpackaged" value="${packageName}"/>
											</then>
											<else>
												<ac:var name="work.unpackaged" value="@{unpackaged}"/>
											</else>
										</ac:if>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>
						<ac:var name="loop_index" value="1"/>
						<ac:for list="${sf.APEX.testClasses}" param="apexTestCases">
							<sequential>
								<ac:if>
									<equals arg1="${env_index}" arg2="${loop_index}"/>
									<then>
										<ac:var name="check.APEX.testClasses" value="@{apexTestCases}"/>
										<ac:var name="work.APEX.testClasses" value="@{apexTestCases}"/>
									</then>
								</ac:if>
								<ac:math result="loop_index" operand1="${loop_index}" operation="+" operand2="1" datatype="int" />
							</sequential>
						</ac:for>
						<!--ac:if>
							<not>
								<equals arg1="${check.APEX.testClasses}" arg2="none"/>
							</not>
							<then>
								<ac:var name="work_index" value="1"/>
								<ac:for list="${check.APEX.testClasses}" param="apexTestCases" delimiter="|">
									<sequential>
										<ac:if>
											<not>
												<equals arg1="${work_index}" arg2="1"/>
											</not>
											<then>
												<ac:var name="work.APEX.testClasses" value="${work.APEX.testClasses},@{apexTestCases}"/>
											</then>
											<else>
												<ac:var name="work.APEX.testClasses" value="@{apexTestCases}"/>
											</else>
										</ac:if>
										<ac:math result="work_index" operand1="${work_index}" operation="+" operand2="1" datatype="int" />
									</sequential>
								</ac:for>
							</then>
						</ac:if-->
					</then>
				</ac:if>
				<ac:math result="env_count" operand1="${env_count}" operation="+" operand2="1" datatype="int" />
			</sequential>
		</ac:for>
		<echo message="Environment      : ${work.envName}"/>
		<echo message="        ServerURL: ${work.serverurl}" />
		<echo message="         username: ${work.username}"/>
		<!-- echo message="         password: ${work.password}"/ -->
		<echo message="  deploy location: ${work.deploy.location}"/>
		<echo message="    repo location: ${work.repo.location}"/>
		<echo message="       unpackaged: ${work.unpackaged}"/>
		<echo message="APEX Test Classes: ${work.APEX.testClasses}"/>
		<!-- echo message="    packageNames: ${work.packageNames}"/ -->
		<echo message="================================================="/>
		<ac:if>
			<not>
				<equals arg1="${env_count}" arg2="2"/>
			</not>
			<then>
				<echo message="To Environment   : ${to.envName}"/>
				<echo message="        ServerURL: ${to.serverurl}" />
				<echo message="         username: ${to.username}"/>
				<echo message="  deploy location: ${work.deploy.location}"/>
				<echo message="    repo location: ${work.repo.location}"/>
				<echo message="       unpackaged: ${work.unpackaged}"/>
				<echo message="APEX Test Classes: ${work.APEX.testClasses}"/>
				<echo message="================================================="/>
			</then>
		</ac:if>
		
	</target>

	<target name="clean">
		<ac:if>
			<isset property="clean"/>
			<then>
				<echo message="Performing clean on ${work.deploy.location}...."/>
				<delete includeEmptyDirs="true" verbose="true">
					<fileset dir="${work.deploy.location}">
						<include name="**" />
						<include name="**/*.*" />
					</fileset>
				</delete>
			</then>
		</ac:if>
	</target>

	<!-- ===================================================================================================================================================== -->
	<!-- Salesforce extract/deploy related targets -->

	<target name="retrieveNamedPackage" depends="setEnv">
		<echo message="---------------------------"/>
		<echo message="Inside retrieveNamedPackage"/>
		<echo message="---------------------------"/>
		<input message="Change Set Name" addproperty="work.changesetname" />
		<input message="Output Package name" addproperty="work.packagename" />

		<echo message="Retrieving package ${work.changesetname} saving to ${work.packagename}..."/>
		<mkdir dir="${work.deploy.location}/namedPackage" />
		<sf:retrieve
			username="${work.username}" 
			password="${work.password}" 
			serverurl="${work.serverurl}" 
			retrieveTarget="${work.deploy.location}/namedPackage" 
			singlePackage="false"
			apiVersion="43.0"
			packageNames="${work.changesetname}" />
		<echo message="${work.deploy.location}/namedPackage/${work.changesetname}/package.xml to ${work.packagename}"/>
		<copy file="${work.deploy.location}/namedPackage/${work.changesetname}/package.xml"
			tofile="${work.repo.location}/${sf.package.location}/${sf.release.branch}/${work.packagename}" overwrite="true" failonerror="true"/>
	</target>

	<!-- Git and Migration tool targets -->
	<target name="build-PackageXML" depends="noproxy,setEnv">
		<!-- Change to proxy if do not want to use proxy -->
		<!-- Create tmp folder if missing -->
		<mkdir dir="tmp"/>
		<GeneratePackage_xml
            sfUserName = "${work.username}" 
            sfPassword = "${work.password}"
            sfServerURL = "${work.serverurl}"
            packageXMLPath = "${work.deploy.location}/Package.xml" 
        	packageXMLTemplate = "${work.packageXMLTemplate}" 
           	orgName="${work.envName}"  />

	</target>

	<target name="extract" description="Extract all configuration from the org based on package.xml to local repository">
		<ac:for list="${envName}" param="env.name">
			<sequential>
				<echo message="========================================="/>
				<echo message="Processing environment: @{env.name}"/>
				<ac:var name="work.envName" value="@{env.name}"/>
				<antcall target="extract-step">
					<param name="envName" value="@{env.name}"/>
				</antcall>
			</sequential>
		</ac:for>
	</target>


	<target name="extract-step" depends="clean,setEnv" description="Extract step for an individual environment-configuration from the org based on package.xml to local repository">
		<mkdir dir="${work.deploy.location}"/>
		<!-- Retrieve the contents into another directory -->
		<ac:for list="${work.unpackaged}" param="unpackage.name" delimiter="|">
			<sequential>
				<echo message="Extracting unpackaged from ${work.serverurl} to ${work.deploy.location} using package ${work.repo.location}/${sf.package.location}/${sf.release.branch}/@{unpackage.name}" />
				<sf:retrieve
					username="${work.username}"
					password="${work.password}"
					serverurl="${work.serverurl}"
					maxPoll="${sf.maxPoll}"
					pollWaitMillis="${sf.pollWaitMillis}"
					retrieveTarget="${work.deploy.location}/src"
					unpackaged="${work.repo.location}/${sf.package.location}/${sf.release.branch}/@{unpackage.name}"/>
			</sequential>
		</ac:for>
		<ac:if>
			<isset property="copy"/>
			<then>
				<echo message="Performing copy from ${work.deploy.location}/src to ${work.repo.location}/src"/>
				<copy todir="${work.repo.location}/src">
				  <fileset dir="${work.deploy.location}/src"/>
				</copy>
			</then>
			<!-- ac:if>
				<isset property="push"/>
				<then>
					<echo message="Pushing code from ${work.repo.location}/src to ${sf.repository}/${sf.develop_branch}"/>
					<copy todir="${work.repo.location}/src">
					  <fileset dir="${work.deploy.location}/src"/>
					</copy>
				</then>
			</ac:if -->
		</ac:if>
	</target>

	<target name="deploy" depends="setEnv,prepBuildDir,retrieveCurrentFlows,findFlowsToDeploy" unless="file.found" description="Deploy to the SF Org based on the package.xml">
		<echo message="Deploying the Package ${work.unpackaged} from ${work.deploy.location} to ${work.serverurl}--single package" />
		<copy file="${work.repo.location}/${sf.package.location}/${sf.release.branch}/${work.unpackaged}"
			tofile="${work.deploy.location}/src/package.xml" overwrite="true" failonerror="true"/>

		<ac:if>
			<isset property="check"/>
			<then>
				<echo message="###################################################################################################"/>
				<echo message="Performing a Check deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
				<echo message="###################################################################################################"/>
				<sf:deploy
					username="${work.username}"
					password="${work.password}"
					serverurl="${work.serverurl}"
					maxPoll="${sf.maxPoll}"
					pollWaitMillis="${sf.pollWaitMillis}"
					singlePackage="true"
					ignoreWarnings="true"
					deployRoot="${work.deploy.location}/src"
					allowMissingFiles="true"	
					checkOnly="true"
					logType="Detail"
					rollbackOnError="true"/>
			</then>
			<else>
				<sf:deploy
					username="${work.username}"
					password="${work.password}"
					serverurl="${work.serverurl}"
					maxPoll="${sf.maxPoll}"
					pollWaitMillis="${sf.pollWaitMillis}"
					singlePackage="true"
					ignoreWarnings="true"
					deployRoot="${work.deploy.location}/src"
					allowMissingFiles="true"	
					logType="Detail"
					rollbackOnError="true"/>
			</else>
		</ac:if>
	</target>

	<target name="deploy-code" depends="setEnv,prepBuildDir,retrieveCurrentFlows,findFlowsToDeploy" unless="file.found" description="Deploy to the SF Org based on the package.xml">
		<echo message="Deploying the CODE Package ${work.unpackaged} from ${work.deploy.location} to ${work.serverurl}--single package" />
		<!-- input message="Enter scripts to be executed:"  addproperty="execute_tests"/ -->

		<copy file="${work.repo.location}/${sf.package.location}/${sf.release.branch}/${work.unpackaged}"
			tofile="${work.deploy.location}/src/package.xml" overwrite="true" failonerror="true"/>
		
		<ac:var name="runTests" value=""/>
		<ac:for list="${execute_tests}"  param="env.package.name" delimiter="|">
			<sequential>
				<ac:var name="runTests" value="&lt;runTest&gt;@{env.package.name}&lt;/runTest&gt;${runTests}"/>
			</sequential>
		</ac:for>
		
		<echo message="preparing to execute the following scripts: ${runTests}"/>

		<ac:if>
			<isset property="check"/>
			<then>
				<echo message="###################################################################################################"/>
				<echo message="Performing a Check deploy of ${work.deploy.location}/src to ${work.serverurl}..." />
				<echo message="###################################################################################################"/>
				<sf:deploy
					username="${work.username}"
					password="${work.password}"
					serverurl="${work.serverurl}"
					maxPoll="${sf.maxPoll}"
					pollWaitMillis="${sf.pollWaitMillis}"
					singlePackage="true"
					ignoreWarnings="true"
					deployRoot="${work.deploy.location}/src"
					testLevel="RunSpecifiedTests"
					allowMissingFiles="true"	
					checkOnly="true"
					logType="Detail"
					rollbackOnError="true">
					<runTest>insert Apex Tests here</runTest>
				</sf:deploy>
			</then>
			<else>
				<sf:deploy
					username="${work.username}"
					password="${work.password}"
					serverurl="${work.serverurl}"
					maxPoll="${sf.maxPoll}"
					pollWaitMillis="${sf.pollWaitMillis}"
					singlePackage="true"
					ignoreWarnings="true"
					deployRoot="${work.deploy.location}/src"
					testLevel="RunSpecifiedTests"
					allowMissingFiles="true"	
					logType="Detail"
					rollbackOnError="true">
					<runTest>TestClass1</runTest>
				</sf:deploy>
			</else>
		</ac:if>
	</target>

	<!-- ===================================================================================================================================================== -->
	<!-- git related targets -->

	<target name="git-clone" unless="file.found" description="Create directory structure, clone the remote repository and the pull that latest source">
		<echo message="Cloning the repository ${sf.repository} to ${sf.repo.location}" />
		<echo message="Deleting all extracted directories...${sf.repo.location}	"/>
		<delete dir=".git"/>
		<delete dir="./repo/src"/>
		<!-- defaultexcludes remove=".gitignore"/ -->
		<delete includeEmptyDirs="true" verbose="true">
			<fileset dir=".">
				<include name="${sf.init.repo.location}/*.*" />
				<include name="${sf.init.repo.location}/.gitignore" />
				<include name="${sf.init.repo.location}/.*" />
				<include name="${sf.init.repo.location}/**/*.*" />
				<include name="${sf.init.repo.location}/.*.*" />
				<exclude name="*,xml" />
				<exclude name="*build.*" />
				<exclude name=".gitignore" />
			</fileset>
		</delete>
		<delete dir="${sf.init.repo.location}"/>
		<git command="init" />
		<git command="clone">
			<args>
				<arg value="${sf.repository}" />
				<arg value="${sf.init.repo.location}" />
			</args>
		</git>
		<git command="checkout">
			<args>
				<arg value="-b" />
				<arg value="${sf.develop_branch}" />
			</args>
		</git>
		<git command="status" />
	</target>

	<target name="git-pull" unless="file.found" description="Update the current local repository from the remote repository">
		<ac:if>
			<isset property="setBranch"/>
			<then>
				<ac:var name="branchName" value="${setBranch}"/>
			</then>
			<else>
				<ac:var name="branchName" value="${sf.develop_branch}"/>
			</else>
		</ac:if>
		<echo message="Pulling updates from the repository ${sf.repository} (branch ${branchName}) to ${sf.repo.location}" />
		<git command="pull">
			<args>
				<arg value="-v" />
				<arg value="origin" />
				<!-- arg value="${sf.repository}" / -->
				<arg value="${branchName}" />
				<!-- arg value="${dev.location}" / -->
			</args>
		</git>
		<git command="status" />
	</target>


	<target name="git-push" description="Push changes in the local repository to the remote repository">
		<ac:if>
			<isset property="commitMessage"/>
			<then>
				<ac:var name="commit-message" value="${commitMessage}"/>
				<echo message="Commit message passed in: ${commit-message}"/>
				<!-- copy todir="${work.repo.location}/src">
				  <fileset dir="${work.deploy.location}/src"/>
				</copy -->
			</then>
			<else>
				<input message="Commit message" addproperty="commit-message" />
			</else>
		</ac:if>
		<ac:if>
			<isset property="setBranch"/>
			<then>
				<ac:var name="branchName" value="${setBranch}"/>
			</then>
			<else>
				<ac:var name="branchName" value="${sf.develop_branch}"/>
			</else>
		</ac:if>
		<echo message="Commiting all changes with message ${commit-message} to branch ${branchName}" />
		<git command="checkout">
			<args>
				<arg value="-b" />
				<arg value="${branchName}" />
			</args>
		</git>
		<git command="add">
			<args>
				<arg value="." />
			</args>
		</git>
		<git command="commit">
			<args>
				<arg value="-am ${commit-message}" />
			</args>
		</git>
		<git command="push">
			<args>
				<arg value="--set-upstream" />
				<arg value="origin" />
				<arg value="${branchName}" />
			</args>
		</git>
	</target>

	<target name="extract-push" description="Extract all configuration from the org based on package.xml to local repository and then push to the remote repository">
		<echo message="##Extracting from the url ${work.serverurl} and pushing to the repository ${sf.repository} from ${sf.repo.location}..." />
		<antcall target="git-pull"/>
		<antcall target="extract"/>
		<antcall target="git-push"/>
	</target>

	<!-- ===================================================================================================================================================== -->
	<!-- worker related targets -->

    <target name="retrieveCurrentFlows" depends="">
       <sf:retrieve username="${work.username}"
       	password="${work.password}"
       	serverurl="${work.serverurl}"
       	retrieveTarget="build"
       	unpackaged="flowDefinition.xml" />
    </target>

    <target name="prepBuildDir">
       <delete dir="build"/>
       <mkdir dir="build"/>
    </target>

  	<target name="findFlowsToDeploy">
  	   <script language="javascript"><![CDATA[
          var File = java.io.File;
          var FileWriter = java.io.FileWriter;
		  var deployDirectory = project.getProperty( "work.repo.location" );
		  var release       = project.getProperty( "sf.release_branch" );

          function version(xml) {
             var matches = (''+ xml).match(/activeVersionNumber>(\d+)</);
             if (matches) {
                return parseInt(matches[1], 10);
             }
          }

          function getFileContents(javaFile) {
             var contents = '';
             var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(javaFile.getPath()), java.nio.charset.Charset.forName('UTF-8'));
             for (var i = 0; i < lines.size(); i++) {
                contents += lines.get(i);
             }
             return contents;
          }

          function getFlowVersion(flowFile) {
             var content = getFileContents(flowFile);
             return version(content);
          }

          function createFileset(dir) {
             var fileset = project.createDataType('fileset');
             fileset.setDir(new File(dir));
             return fileset;
          };

          function removeLinesFromPackageXML(removeLines) {
            packagexml = new File(deployDirectory+'/src/', "package.xml");
            var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(packagexml.getPath()), java.nio.charset.Charset.forName('UTF-8'));
            var fr = new FileWriter(deployDirectory+"/src/package.xml");

            outer: for (var i = 0; i < lines.size(); i++) {
              for (var j = 0; j < removeLines.length; j++) {
                if (lines.get(i).contains(removeLines[j])) {
                  java.lang.System.out.println("Removing the following from package.xml: " + removeLines[j]);
                  continue outer;
                }
              }
              fr.write(lines.get(i));
              fr.write(java.lang.System.getProperty("line.separator"));
            }
            fr.close();
          }

	        function getFlowsToDeployFromXML() {
	          packagexml = new File(deployDirectory+'/src/', "package.xml");
	          var lines = java.nio.file.Files.readAllLines(java.nio.file.Paths.get(packagexml.getPath()), java.nio.charset.Charset.forName('UTF-8'));
	          var flowsWeWantToDeploy = new Array()
	          outer: for (var i = 0; i < lines.size(); i++) {
	            if(lines.get(i).contains("Begin Flows")) {
	                var count=1;
				        do {
				          if ( /<members>(.+)<\/members>/.test(lines.get(i+count)) ) {
				            var pushing = /<members>(.+)<\/members>/.exec(lines.get(i+count))[1];
				            flowsWeWantToDeploy.push(pushing);
				          }
				          count += 1;
				        } while(!lines.get(i+count).contains("End Flows"));
	                break outer;
	            }
	          }
	          //java.lang.System.out.println(flowsWeWantToDeploy[0]);
	          return flowsWeWantToDeploy;
	        }
          var flows = getFlowsToDeployFromXML();
          var flowsWeWantToDeleteFromXML = new Array();
          for(i = 0; i < flows.length; i++){
              var srcVersion = flows[i].split("-")[1]
              var filename = flows[i].split("-")[0] + ".flowDefinition";
              var remoteFlowDefinition = new File(deployDirectory+'/build/flowDefinitions/', filename);
              if(!remoteFlowDefinition.exists()){
                  continue;
              }
              var remoteVersion = getFlowVersion(remoteFlowDefinition);
              if(remoteVersion == null) {
                  continue;
              }
              if(remoteVersion == srcVersion) {
                  flowsWeWantToDeleteFromXML.push(flows[i]);
                  continue;
              }
          }
          removeLinesFromPackageXML(flowsWeWantToDeleteFromXML);

  	   ]]></script>
  	</target>
	
	<!-- ===================================================================================================================================================== -->
	<!-- OOTB Force.com Migration Tool targets -->


	<!-- Retrieve an unpackaged set of metadata from your org -->
	<!-- The file unpackaged/package.xml lists what is to be retrieved -->
	<target name="retrieveUnpackaged">
		<mkdir dir="retrieveUnpackaged"/>
		<!-- Retrieve the contents into another directory -->
		<sf:retrieve username="${work.username}" password="${work.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="retrieveUnpackaged" unpackaged="unpackaged/package.xml"/>
	</target>

	<!-- Retrieve all the items of a particular metadata type -->
	<target name="bulkRetrieve">
		<sf:bulkRetrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" metadataType="${sf.metadataType}" retrieveTarget="retrieveUnpackaged"/>
	</target>

	<!-- Retrieve metadata for all the packages specified under packageNames -->
	<target name="retrievePkg">
		<sf:retrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="retrieveOutput" packageNames="${sf.pkgName}"/>
	</target>

	<!-- Deploy the unpackaged set of metadata retrieved with retrieveUnpackaged and run tests in this organization's namespace only-->
	<target name="deployUnpackaged">
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="retrieveUnpackaged" rollbackOnError="true"/>
	</target>

	<!-- Deploy a zip of metadata files to the org -->
	<target name="deployZip">
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" zipFile="${sf.zipFile}" rollbackOnError="true"/>
	</target>

	<!-- Shows deploying code & running tests for code in directory -->
	<target name="deployCode">
		<!-- Upload the contents of the "codepkg" directory, running the tests for just 1 class -->
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" testLevel="RunSpecifiedTests" rollbackOnError="true">
			<runTest>SampleDeployClass</runTest>
		</sf:deploy>
	</target>

	<!-- Shows deploying code with no TestLevel sepcified -->
	<target name="deployCodeNoTestLevelSpecified">
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" rollbackOnError="true"/>
	</target>

	<!-- Shows deploying code and running tests only within the org namespace -->
	<target name="deployCodeRunLocalTests">
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" rollbackOnError="true"  testlevel="RunLocalTests"/>
	</target>

	<!-- Shows removing code; only succeeds if done after deployCode sessionId="${sf.sessionId}" -->
	<target name="undeployCode">
		<echo message="Undeploying from ${sf.serverurl}..." />
		<sf:deploy username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="removecodepkg"/>
	</target>

	<!-- Shows retrieving code; only succeeds if done after deployCode -->
	<target name="retrieveCode">
		<!-- Retrieve the contents listed in the file codepkg/package.xml into the codepkg directory -->
		<sf:retrieve username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" retrieveTarget="codepkg" unpackaged="codepkg/package.xml"/>
	</target>

	<!-- Shows deploying code, running all tests, and running tests (1 of which fails), and logging. -->
	<target name="deployCodeFailingTest">
		<!-- Upload the contents of the "codepkg" package, running all tests -->
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" testLevel="RunAllTestsInOrg" rollbackOnError="true" logType="Debugonly"/>
	</target>

	<!-- Shows check only; never actually saves to the server -->
	<target name="deployCodeCheckOnly">
		<sf:deploy username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" deployRoot="codepkg" checkOnly="true"/>
	</target>

	<!-- Shows quick deployment of recent validation. Set the property sf.recentValidationId to your recent check only deployment Id -->
	<target name="quickDeploy">
		<sf:deployRecentValidation  username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" recentValidationId="${sf.recentValidationId}"/>
	</target>

	<!-- Shows cancel deployment of deploy request either pending or in progress. Set property sf.requestId to Id of pending or in progress deploy request -->
	<target name="cancelDeploy">
		<sf:cancelDeploy  username="${sf.username}" password="${sf.password}" serverurl="${sf.serverurl}" maxPoll="${sf.maxPoll}"  pollWaitMillis="${sf.pollWaitMillis}" requestId="${sf.requestId}"/>
	</target>

	<!-- Retrieve the information of all items of a particular metadata type -->
	<target name="listMetadata">
		<sf:listMetadata username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}" metadataType="${sf.metadataType}"/>
	</target>

	<!-- Retrieve the information on all supported metadata type -->
	<target name="describeMetadata">
		<sf:describeMetadata username="${sf.username}" password="${sf.password}" sessionId="${sf.sessionId}" serverurl="${sf.serverurl}"/>
	</target>
</project>
